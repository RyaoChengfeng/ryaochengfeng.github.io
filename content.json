{"meta":{"title":"Ryao's Blog","subtitle":"——I DWELL IN POSSBILITY——","description":"|个人博客|","author":"Ryao","url":"https://blog.ryaoknw.site","root":"/"},"pages":[{"title":"","date":"2022-09-21T18:12:34.144Z","updated":"2022-09-21T12:55:02.882Z","comments":true,"path":"404.html","permalink":"https://blog.ryaoknw.site/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2022-09-21T18:12:34.144Z","updated":"2022-09-21T12:55:02.882Z","comments":true,"path":"about/index.html","permalink":"https://blog.ryaoknw.site/about/index.html","excerpt":"","text":"About meHi! I am a student of Huazhong University of Science and Technology. InterestsCoding !!!General: Graph: Skill: ACGN !!! Feeling free to friend me on Bangumi! @Ryao:"},{"title":"所有分类","date":"2022-09-21T18:12:34.144Z","updated":"2022-09-21T12:55:02.882Z","comments":true,"path":"categories/index.html","permalink":"https://blog.ryaoknw.site/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-09-22T06:29:48.299Z","updated":"2022-09-22T06:29:48.299Z","comments":true,"path":"customized/custom.css","permalink":"https://blog.ryaoknw.site/customized/custom.css","excerpt":"","text":""},{"title":"Friends","date":"2022-09-21T18:12:34.144Z","updated":"2022-09-21T12:55:02.882Z","comments":true,"path":"friends/index.html","permalink":"https://blog.ryaoknw.site/friends/index.html","excerpt":"这里是Ryao的好伙伴们。 欢迎发邮件或者在这个页面下发布留言来申请友链~","text":"这里是Ryao的好伙伴们。 欢迎发邮件或者在这个页面下发布留言来申请友链~"},{"title":"","date":"2022-09-21T18:12:34.144Z","updated":"2022-09-21T12:55:02.882Z","comments":true,"path":"mylist/index.html","permalink":"https://blog.ryaoknw.site/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-09-21T18:12:41.328Z","updated":"2022-09-21T12:55:02.882Z","comments":true,"path":"tags/index.html","permalink":"https://blog.ryaoknw.site/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"向这狗娘养的世界","slug":"向这狗娘养的世界","date":"2023-02-26T08:56:50.000Z","updated":"2023-02-27T01:26:12.278Z","comments":true,"path":"2023/2/7e899c277a7b/","link":"","permalink":"https://blog.ryaoknw.site/2023/2/7e899c277a7b/","excerpt":"[ENCRYPTED]今日、海を見た。もう怖くない。","text":"688c91111db14f9d3aa396aa4128ccffdacdbe782570004c361f8b69f19568aeeeadaff6c616a36466967f4aa1a0a0541960d207ab8a56812ebfb99e843497742848826da20fefa43941c2853ce072323a7e60b2c9559d04c588a7552a5530ee3889a60a36503823ec713f283d04817a3b749f04c92a972c7e7a8dcfb81a4a6a7172b07c75c599cd90020bb7fb7aa784302b8a8e8af36df4e97cf259725f0758d3aefe0dc89bc726a1b0ff4cdf3f4faa30c4fd392b2491865d5e85402cefa43acd170a42cc49d67ba4747a931bca1fdb7b41e1731dd443c1e18e273648c845686c1fb0fbb325f8320097076347b7a41c8d88e424a5e2f637e5c2e370a77ad436840fb61fe7d2203e9047f9382477e81e3cfcc84dfd6bf096152c61a8231d130cfd6f96181d3a75460696d9156ba828d1955f881e42f33967a2a6d94cf8885ab396726c4e5dc14a112d2b5ba8b155a4dbac73f874e8d5e0b3ad3773f60f4fd4b99c0ead70780d146b0ad8815c648b967b92a5000f281b5ffeed6e9b12a79c27dc9fda1403c9c8e1d079eca4d241da2d7be8903947522f48497bc459b88fa8236848ff547d43d99c4b0bf7f7c663cbd50373651f7e438107a465eb9c4a356038c218de855385d207d9850236266a54b88c04e51f15e3c7563757cba571879de170fccd457b6dd4bf3fd0010798a07f6490dea2ec367ab9053ac9902417bd067d9d7e7fe1ea82e7e77f752d94d85b770eccba06bbd9398099a8ada08e449f90ff8d95a85e3fdef0dab66f4540033c7325c93b600fb46896fb8df6ffe02af3b99cd34ba1f104201f1ac2bc534590a74cba0063bd94e60ec64df3b4548f9805c97aab4bb75a62323fc38de12699db59ab79cca48574d457b66cdec08bcb5604a30150acf2713bcc44e11f90f850c5285735ab46a1b645098ff8acc96780abc2a8d68d07293724fcef0ab0d85dd3384997f898d0e426f1d73d2214f4bf7870fccd8fa5b60a57ab69b2227a39c668f9fec735ab82e2e8f5cd890097cc4c8961c61366017e0c60a313c4fff6477894e9bbb8729beb84f604dea2d9b88a1920dcde8b0cf89169b456459edf54a65d8e3a4472cc894781d686bf54d95f8e67385be8e7003b846a04217609aec65d6dc6fe8b232b97fddd4f6ea1a4a671ecf89e79d9ec7982cacb142a6b1e918349d780de7ee82dbebd0278a6c6a08b379f1149fee6f7d2fd5838d2199eae2eac771278fb872f3dc04edc0884f3fe1efa84dea2f630631a1aa20ee552d2795872b17498a9191f257e5accf64f12d10f1d7076978e84b2b120d457e3a43adba8f6a21e5db6f65de89a8f9aade32400cfcc860ea6cb1deb7eb613cd843c878e495e0a168ee7d06610a950cdd38eb774051ba709c6c4bcae1b1d0a5ee2cad40713b608c65dd6bd5f01a6a26ab016b60e80e3a88a2bc770fdc1d9a19d03957e449f6b2aeb8860dd5e4bfd41759a9f361c11c9bbb6254bdabe60fae78025c17fa8e477f0ca0468f04f41092052d6c574176d3b57217144ce9126ff727b89ed8b27c4f5e2f133b3c3a168b671a4bb23b2544e47082dfc30db6d094de5cbf574aba8308e0d99a834e589126b1e56f9b282c28b330bb883af10bd511a9de5f8cbe275aced1a36e8d94d4b7f95c922956ab3f7a3ad5fe5b25412130028f1e3c72d9796de840514c322fd44e34327af30ffd35791256c4dfe4773b16a577e48365cc74fae7eccb62091cee796b9bd7829f40184270de27ba5c8b3574375b9effc0c52d25e906276aba95bfaff8c4f52ab90006f256155b3057ef208742fe0ba82967ce35abca9265a056b58176a7d15e5c079dbe4a5137a69f9d0c7f281af7835490a0bd8329590e9635c92c96dc0dcb494e7d12c4ebb60abbe173ed67488b7fee843ff486e5283242c57e1cfb67370ff1e78779621c5b12d8a3519c7b6b0a7cf703add8f23ad043062df6a744968f91aaa99dc1ba055367a975d3083c75b18fa356cfc5824651ecd029fb9271be62e647d5e0a4e889889d5c88d56e1c925176f70d4441930d76e5962a711f5b8caffb641f208a417a0867a07fcd7d8ec88aabc655c7dad853bbabd7f457ad51007c885ed7bd4baa5d07d993a98fc819d6bfb1642491d4ae15b23073940880ca86100a6ab58c475e7d15500ae38a2539cfb947d422270fe69ae743e0961c2f395be4eed3f093b45aa32e66b6bdc895280fbd43998f80dd9d0e7e9e6f59dc3e981d09ff13a86d10b3b83509d392cf3e1200403c334179d9c8282fc27e7af0ae3324deb2432e5998921b7bdb269281635dd16c3f999f0adabd9825554c97417f99151813e6cb7d66df2ffbb0bcd6794214717997f527c619dc3e0bb0ba038f5a84551b6d567f81fe40c74b42d32b55b8a5249e7f614f61633257167dbd79e529bb829907f9b0296b322fcc90d65a2ed16c7686be1f4888175a694b59ebbf772b3cf251323bf616fb4de01d288a3d83a225d035cbcca3e43097ba1d9dd70a645043db3c46240381a01015f1c97895fc0d35c670d76be4ac94203fd7d444d36b0d58a37bb0405a1ae4ea71f8c49b0a24dbea7039e599bc2a49cb8c68f97ddf127ddc4fef182fa6523894904793fdfee30ded8602daf2d626b08acf1ab59152395591623509e29fb65bbbe94885a14c806f4f1f086ffb0aa6cffa5b7c519968bd18fde006778ff869cbd85f33a1457fd308d36e1b09419c1c22cd0c096f0cd4425612efedb5d0cfc887b4c4c581fc0bb1d37940508b14e3f1ea3c1842349574cef8d8562e1759908ec98bcdeaa580b9663ff0b8c3d1377520da1e35ac1fcd01233ff791c3ef885ccc87b19e1750a7640fbc6a47031e288121ce69efb5de9e1ea98c2fbf624973c9f9fe151b81ed69f5316b3c6630ecf402e0446927cfe5d6b6c7c35b5addf209b9b7941bab060e10bc89478bc47614771fe05be045b4511934209e8313a802f7e958c074445b8177988f087b11dce647494c75704e984225491ed95bee058eba1107e826b07b30c6b5df342290467b020c081e56d20e948d5ebcb285f33773d29fa22de001a44c280752bf418cade93cdc3c46cb6035e3f6c910d3b9fd789807e68669d5a9836b32215e5dfeb67e2d1952d1ea1997f798397360d8cdebf2455ecd6aa94d0ca82bac22ddaaf568f14734dc617e7544a15e82fe3d9af94a66d9f5663d73bdb1f2f58ae3b50fffe5228fdb9408b1e869c486385aed1fb4f0afe75b647280cd6d2563efcd4defbfc14e87ef2593e1a3f1c1d8e69622a15d044b68234095557979f29cd7b7b6e8ac16c203cfede481a98034f4802c18c89ef06deaa120af9d88aa099b71563f96e6b62ee6887b3be5749a0b07f4c262aa781918f676383655b2e91bf63ec3c0bf0a13cb2bcfbb4aa3ef89b528939ac70f19f5ecfc363fd015ba916afbba0e4301c5cd92de6fbfe204ec22740cd095e643788d53aabd40f5ebcbfa6f2344038d9ce109b5e87be46015acc7dedbe3fc38c3909c222e8f7e38f7bc4ead9eee60c9df7baecc5ac58d17c909759bac6eccd2970736aa57012a5d3e9d377d3dfd4fd28910d147c2d1e487650caf9dfe162706b6a49a8bf866371918bcc7408d3040df3041eadc3030c8e37f36e1e4145d81da75e6aba6391e675e2a1821b7d58838cf5fe53ec30c3e13346a9affa506d88125df93a9b78affae751dfa74f7c668ee8cac51d4fd913a702314ecd0b19927ec697ae0f241699d433d4cd67d1753aa40014152d3c636aed752d13b31b538034ca4a98a46539da0085e6d0dc52768b3cad183a0001e6477e226590969d6b75936c2a6aeedea51d4e9243d642f311bc75d57321bdf197e9aa6a0a92ea6293edb1de8b734facce373d339cbbb9a33aae119e2838b1123944487b2828ce8ccc9435cdaca33f95ae6dccfd29f17b7dfd0c5e8660afafd688ecbadd2b78752b38e125c85401caec0f7372767f1f96f20cc52efb4d2c6413ce594a14d50cc71df755ceaef7bed9ebdf6293d9dfa9c7ffc8ef1903c6c12147d0f8368fdf5ff876e0b18d0e75a1d803b7d8f26dd49eba0059f394bdb7e07d3ef5d6d490e6ee7d307459a0206e39233589950b476b195ba31c5d3b47d7dbc4f56b10d19124ce5348ebb47fa7c482560a2231f4dbb077667a2a376adedf030bb3e85745e9a4b202d0995f03aab0b38b217e77cf3f11030b2dad42f10301209fcc217548a4529a151257037117450405b32f2dcc32232d9b7944dac72ae090db254134107c032258167080e555df52dcf39a15c4639ebbf4f3688a391409695f39dda4ceb2141330b771b881fb9fd48d81efd659bbc5bcced5a360083e09e625a6b2bee797e3b867ce21740462782e4482f5dd36e4ebc49f5dafae9374f18f943331d9d8837353771c5a448f8cd85969a1e2021982f2bdfc19fd56c6f49fe4088d49fe57bf8440faa88e83ca41f8db39a1fa267aac69c4e163e3fe2bbc3aaa06852cde374fb9a01134d47203f782b033e1dcd575c06cda55d739b1f5d22038a17a5f00b25e4ad5c0521b2e9eb7f4436cb0c7b441233c69c8e40af3f692e937666b1577d1c3b3dc367c8a694d5ee79d6c04a2b545a909a1c27609d110209d0c27be029cc6e0d0141147339ddeed6579d81c15205cbb88f64e313c03580157a2abe76f64be2af24749c964158f4aa33592b37e7b719b47cccf5f56426775102bd2c8464ebc17871d20c0c7a4a5be68c4b68b116a9f566bb7491d5a4b8783aa66c5ca88b1b4e0865c4de42345a0e08fe62e166863b8caece8575449ee2c5f61e0b98b99b06233762d5cef9b999b322b7f081f6f9670c9ad23b5f6f9143c4d1d9c5c221e7b7abcaaaf2e39d95b117887c85e38982238c57d49f01decaab6659c060a697fbed221d7cc8391444cfda0ed491e5e4cb20beabe7cc3e74fcada5148ed4726157ae41c3fcc6b3d19ff830a6f613e64e6306d8684168994dda1026ebec21122d72e2e7a100d5a16bc75a9ea12afa062f6a5bdf13045235effba5c048cde334d5b15aba0b570060b857e338db8374162eaf55de3cd9693541355a3d2811c09cc2af2c8439754ddb870a6b738c02f1045be89fbc1651b32218485b109919156377f24584025c16b77d81ac2e17a230dff4860bfb962cdfa93528bcd4c38a6a17d2275a1d662d71c3fae4ef1e92f26e2904664fb8c3bfa16c55a30d767150e3c9541893b793aeec379cac1f3da29f90ee548f4a0d6027e98d2ebd102c5e42d0bba1de46c5acfe8397be29f00cc88a85181486074b85813b3776d8a600f5870c5a08b34d36dc159533091097356e4645f43f78691bb8edc8f7823381bea0b3071882c4c84c276c639009cfd3f2a486248e57b2f7596ffb856f2148790a71f1c30aaabc204d1e3b4310f86559d5efd50ac591f388097c1a3a3763032a4404b68c0c7a798e415542cc3012dc70836ed5e0e9be174ddaf2ebed57e108e9cb2adb2bd604899cfbf9172e5353008c47f5a28606e0d7aa1cb87e0b3426d08b7f255e88c6666b324ea7853825b054c9ca3ed7681170a5cf8a76c0ff509efb2283c582fb877fd232cf5ef522cd01ecc9475ea6d853271badc708be7b60aca30886c6a48086f32a24b881153eec6a443b87863ef017614198fb302d816ad5d374fe11dc4b882e95968e58582faf0354f90d9996f0cf52b5cec03a6c8d710b57ed0cbb153fe9b546e74bcb5b3c76049142dd428d44e4db76052d766d18fb8f895795c7a25e5b89de9bea3eb231574bd40ddac22416154d981b856e47760b3e1f0f326f834177deace521ababef6f54320d8fb4bd4099f4248377ba6224d36a93f023defef3373f33322e6af1f79cec0f87fb5cf1340aa2509c719b4a63a85e0b62ae7066f915fc08b049697889e208b28c2df9187d2cdd87c9c1e696ff8d873c0c0e1eed1d2063825c6ee09c9eb09b8316d541e4d55d638f201a55fcab094a1e273914cb6531fcb2546631a977c4c0aebdcf90182667c76b113718a2e2eabd4eea03e01d2398f77ac68d0d3f3e0a55993813d74916e283f58252b09bbe5f10bd0287fba03054228a0013d145d9577f77009f02dec8dd53cbedbb8870af62e52c04aad8ae7c5a30d055e9df31b6930b4949578e209983d67d982126999019e58ddec9507ba567acecfac4ee8672680f6f9522bcd1d443cf80fdff62edddc8b17d32485662534257d6d952268932af29fba7e9bc46a9f4ba3f60434544c06a2d7e04a12b054a04febce8b361a26f02a4ddde7171d86d0b6f0689584834859d18106181e7d65d6d065865bfee6a141319b8a34582a6c7602139bc0103f931de99ae94729b0a23fa7facd0e032033dc6f0d77cb6c70c48946b59f2bd81fbcaab62bc27395c6b7dc9b44e1c652f963eae3b93df412b6d1c2e456fc1cf8f524eb94bdb5c2a3da15d662a90c72c5e4690764a0751a8ee227c849585697ec04dee202537671992af6a8e957e97bfb4d8526e645f5d28b1651e8aead14bede03cd28a6bc86415a4e3959cd2e63b7a73a55fc5026db86b365359a90ce2752781104fee6f29edc40776d7d2a8a414781dc05fde9588b6dd10b34792313e420994474e93ddfce6b46730d98fc6efb9a1a4ab8cd2beebbb7fc9300f722a06bdd2ad65232926acf0b400c7a16a29d0ce193754c57a1432f9b26dd83977d4da598d14fe1fc5813022779fb4461453cbdf1bc643b82d08729c8b01b8197f06e94f9ad9398542a827b4f2ce6d06f505d8911c392c3f79247dd51d750ba6493c75fb6aa9fdcd817cac1ddc75febe6a107475a83356d11c87c2ce94f6542126e3447c57cf70ca6f6b369c18dffc4710054f3aef4c0879214c26326515f061955ea64c9fef7df2dba609c9dd4c4070450c809f371c6540484c38dd0a6401e342e1858abd42b5f63ca228f5fc066137e3b4d914773bcdbac7cebd9bb0815d9e1ddb2d4f576adfda90000222a89c5557df2bbb11119e0de063a5fd6691cad3f062cea55551a80b7b27056f869017fa7b2026ade8fd921e50bbbf8a2d30fd3206deb9d4caf71eaa3cb8643b51133abc16ec4192f40cffe08c3633dc26d01cfb34e2531f470e702451774f60cee78a5b5ae116e30139ff3c3d9cb9a3bed794de78c35ae85515bbb7e6064c4f6d856b35ba186f62d114a83cad903edc3e7767614acce40fc575d8ce9a7e59d35d35215bd056fdeca0294c798a62089f9e90809e87fd938f37bf605722fdb5da754a6f389ec6eb61b32c7a82bac06738abb20828aa06507d44c5498339e82b85f37456629103e43eabc23dd987f0b0c228427b9ac4b73149f12f47b847104cfb93226cf867c6ba008cdcba8548355806c7bbca1c8994ece7f1776be7dcd1857d5feb2f0a89af007d11a90809d2f3e728df0aa4d790122d89dcd4f3422bf302289fa177741d6c36839128112599d25ecbaa9cc592aa939e83d9ac3d137b8125504b769aab272f8c70fa465be5eeccb5f27685eb23ae116cc919311d6869998aacff6cb28a2506d1ad4f4e0b18197608bbc86cde923bef36121d1ee89b98bbeb82ab2a34440036ac888bce404c12c0c66c593e9e651d9df3ffaed571bd1d6a4f8b93f0436b38245dde2d08913dc07359e967087952c2c239d0a05d6181452c30b433a16a8ca71b374d9116f88a3477e40343af58cfbe66268d7f793a8af40124cdcda2a1f55836a6a1977980ff1d526636954421f01cd26aaf1ced42ab958c7aea235c1a68d081d9a94a2979090b2a37038889761b327cefd8c344a4c39f36e0f4f06ee201eca99f4dbbafd5fb7cdc9ae46ca098ae141e419e426f07945e03e3990e61a3c2e4b48f2005738a800ca37ad0068a28391e6061e6ae623f7b8b7685ac422129f9f54294ac36bd3b86d8e3d2a5607767bd954aedd9e19acdd2c25b308d229095e76b4cfea0fed0b202206142356b4588ff5ff5379b98b5f48fd43432794083f262722984809863c805a5a3b0a0b78234b61e5d94db7cce0ac0cf565e0bf847920cdfac04eca20225bb18e1992605c01d90dc19b64ed6a7ec02970fd5381dcf504d368b0e5d6bc8aae2e59be9adae86014fcd770bbf096825e75852c2a82e57f10aa63e55d5b5c6c57d158131488945a63c9b3a924cf642fe6e1b29f7ff54a4028b0aba8184063898fdb452b18c869a4e9fe034a3040541171f2edbe718f12a9ef0b720c913821e4196b9716d722b4ef4791a3f7ac9fd3cc5f25f2d7eac91bec6633a1b75a468148b9e29d1690bcd19f48a16407eceb0d76251c99ce2eaac18de80cc933df52288f03e3222a77e2b1e8de47f9f1969b371ce52dc0efcfad37502364b6242dd96168ad2bf8652d9447baa8569a203cff2c7cfab08910a1f755ef7b25141a256ee8ee6b08269fdf08392d2ed29cc67d783bf2832e1c005452ac8de8c6272947c4692fb4118f547096bc6c50ca0aba56ea38f7efb72bc19a3088f3d9e51e9e131cf32cdbafe59275f724451f33ff65f5ac0f656738bc280cfb3f9ac24d04e5955c607c0060fbb84493938766b8e3afbb5226dac6358c7b560d47e5316591bea1b668701bd8d95d2cde7db69f7dcde99c2ba7f2a61f54052df4d6f4c8e789b5cf569bfc2f7f454f7051bbd2616d4ed2c2aca5f781a4d733e7abd8bae9189f4305e5d82ddd85b24f86419068957630da33dca436c664cc814c70b5318ad7698056a0e19decbf157b934392ebbc1fe0a9790cbaf7d50a5e68d105bf82af14ca16944663dac6a68a0e54a6261ad16a4365d8a84d2048145ac7495365a023588a8f7626f70e2c8995b7cb94610714042708a7d6f06da46636de3a4feb29d0114685219eacf174c54dc36bad75d99486c1edec1a4e6fc64ca98ea0ef187fd2dadcb4d450378f9a1ace265aed295efe1503f44a83d323d3ce177c27f8995545775ebb13ef8f32218c3e67b0f124f83a3d1042741c6ba1451095f5518bfd7de7318714a6a74cc692238a4cbc8d974f8d06ac8cc03a1cd22c141f8780c6354a84f3c042fb9ed96976d2f6492ca41a2d83793327559a5c44a7a765a462e720818a9d0be2def48366b39b5bca5b38aed283df97ad276b78252eb74a0894b8e797251caf8714fbcfedc5062a67afbb63577c2f3e9c333092314faa2523c3ac28a307bff4cd5e41f1523781d7d248e49f0af125a1ae2eb8dcbca4992651ca4253e7957508819bff9f06f73cd92a1f1fd7ef0984877625037e7cbfd4a1bc2f5c12fe171493d50fa191712f9940ae2f7fbb2fc87ca15547a18d602f9a7740a502d160164faa9d0b953e4d6d8da43b556c703139b5d3e09a6b9aade831fb25a96b80fa42a3797503401caa11714d7df6a82ba7ab3713c2a5496a45d9858b32cbaed4ff906ac195a82dedf37f71ea7a2c385606d55a00d3894c801f379b63c0cdfeaaa19d15d42393aa708d11169989113db71734be2890fe76f6443bcbc8d8e83e74161eee6f32e35f6d3e7a290a6a1b01697f3fdf5042fb91db7f0f4d447a8aefa3bf4da5c4c78191a5a829de7500b2450bb2bb438dbfb70b04d4efee5ad625e3eb54cb3e81a25534e424aec20a778cebfc4e7b48672121ab4f07d91367c891b5cebbe8b85f7bca1e4f2ce4991d31a0d22dfe81950221d70ff1756d48cd1b364ccedfb8be290b925297df442bfa15fc1a3c2374fdcaa56e904b1a11d4424a7622f0f5e2dbb958d59ebdb5ee63fa31287332a5ef5f1a8dcc5a654a0a7b2d208e1ad57f8338a9b6a62252fa9adabff59b957ea12cbd9987f1f8de9522a15adc6f62c8367e7e6ede6f3b7b1eb2dbe1cb229bbb24c4c41111985a9cdfb17db68a00927905745f555e94c2d2080bf5b3361c8a1c7da39b13731ee2005b2008d87a816eeb689a22809638ca73d42233c6db9b4e9fca6cca288b403cd6faf2bfd49687d6a666db4cb72fedb14445a6ce3a18c63dd4902376237cb2bf96f6cf4eaf6e15835d7f519d2cd583d6880525225c03e37f02f64356ffa208ae97eb0ae52c9a81126f65e91c9139c77be8c48f61df690429a74530a9a9807e3c17f07d68afc931006aa6313e6f223cf7f227eecaa0f0e4614eea0a7a41b334a918f9370835508a9820c3527063c4fe026b90a6fc0ac52b176c6bb4b224e10d9c099ab2de3dca777cd75f28583ae5e6ae5e4b2be4be5f94a82f853f5957ee2e011a443c4291a467a25e609dfb6d61e4531dabdede9d00b1ebe51458d5ce9ba64557b51e15676bf024d99c7ce6b00eeee7d455c01725545b5d901ebd2b11401643d6124d84af79430c4acde6b714a459eb11464ae7bcfb74aa7f137052191b2ba106ee67e324961f5f52936646090748a7d914eb2749816833764fe8445e195f72fea591642bb1dd9639cee29def56025590b942e68c1d497a67f9ffdf314b306562aecbd274d48718016260862ee531a1b15ea6ed4d2585cebc835adb177ed313609fbd6b256219f70d4fdeaca6f5e96a64a0f163ed8f4f97dcc10ebc938f1d1e079e698e55e45d1ff98c096132557287b5a1c594c0692f8ba55e7e47ffb018335542ba87e3be795db74912bc0ea482489be08b1a83b9dc9b445779f3f66fc3e4159b5be34a714f91043c5e9c4ab73c31585c6755f7f9124fbfe9e2ea401c1bf1321243f7efdaaa7166919b19661a2663fae7a3ba5f5f9fee854271485b2adc81c21c22059132d9776fb180b04b40cb4728590f7b8e4eae3de83648952db712bd48ead2573a239021102b3e4cf6ba0f2dca171b35f517c3150d99b449945d9e003f2bc7b0ba543092f67cc37ee2de0545e80322cf9b238920b0462cacbc7a68a0d24c037eb2eb62f269a2089948b0a99c64096f3b0b8679e12174bf30a7b7a8f7b38f2a16f281970571e9fbfe131441ecb054cbe19a0220294f2a1863ea004e3fd110947d9d959ad104055fc60936cf75f5033f01c29aca9bbd84fe0941083c0626b9ee349bc8fc767c8bff9061b570d91525ebc1c8643261e45c9dbf41ecea16bd62733b3d17f7f4d73ae7ec4ffe31468be4df96750111d26eea6439745c08955c9da97ec3075f22a1eb9eb4a5e6d24fadb4c4c6e52dea3299b22a0a64dd8a09853e94027c3e8d7c8c9659b70aa2f8ba3a17ee614fbcb9b337815d7ffa8289082d0e139c94a4734f682f0dfca276f4669c6791afaef750044402cfc16e01cdb22e6a8680d707b52f46cffaf6dfcfd3bf0665decffe31c861b8afed963fd8c7451a347807157d367717dec33eeee9c7205fbd960ac4d0213098023d6f3c017dd2f99790059a3d42e3b0c3fece9c35c70d288f251f26f764515a9a3b7144ea90370c19bf1d95e87f901504806f11cffff1fb794fe11b9267428c274f24db5b33e9db59eafbbc3c99099ebafb7e5fb27c28221f6ab6ef6612d17e8f9e8c6b55f430a6d1d57f1d86af549d02d8f3d8ce37e69c9828ac821d80c52d50fbeba2eb58cb124dd57be7d9fce1aea28d48746e935c6e13ab941b1cd0e1a6d4fc21f6fb484bf7e92b2e11dc282ef20ec025c36c2099fdf7003dd1ed4acf601f57822aaffc36b609a120be71da2cbbacda25c23f5c8e3f46b3fae88bc7f6f0e9d6cab7c40ab989078fed53db51346c8da571bd38edfaf0ae09d0989c84754a91b2d6fd09ebe475f9b110f03b9f43ea9e4d8c456104c45190d0ccb417710854e826988cc327e8798cf91bd45a2297222e3a505be75aafc35f38c30185289583626cb26e03d7363b7b77eeb84ce03afd6c96d3ec74f0fd8a2591961335da61367cf9620e732c31aa1fd3e5537d6be47a0988d76110477c7765067e34dcce7177e2b605af1d4435a8f93c9ef76e638bb6d5d0c541d53b4c55d716777108c9a90e2363fac80111b8bbe4721214dd339b46d1a1876e5caaf8e4d41394bd9c19a910c7428775e313da7c4fc20265550a89ba4a17f3fbd51d6e4389ad9f2bfc7bc918f894510ce15608f1c689319ec2ad5c3cabd186a382ef213e3a86f9aaa1e9ee37f52e187f841fe23a08d8d5a540ad4500ab43bd0b98a6a8a60bd9cb5dcd7c2b8d3325ee4024808de9d2e558565b5c754bb2c0aae0393e857b9169ee7bf5616325b1eb5eefbb174d0913071d240f25bcb42e4fe43c3478ffb41982738a48854d4860a2f5d7551402139181fcaf57d80e2c8060e8eeea48045bc88e63beb15150a927a57b9729aab1dddbb785ee458b54aa5d09f065cee35716bacb483b248fc90d7fbd749f768239b68eeea5b15ef1612924ad34791405b762d83baa04ce783dc8fcfda8c755ea2efa7216a329aad514bd03dd0471ab1f3bc84f929705a1acd101dca37306a413ac8e4b3d0e869f93c303b6ed36494935d07ebfdb87c3feb1d25ce4fb2c962dabf679538cdb4b9c78f54e48bc93f988b30f1c8568bafda6ea2454446b19fa599cf65152f28626adab5ddc9ae47e62c56df2618b96db9473822d437204906f210209600a492e7803363fc483d4936222fac8c0ab3439ee9be53b4d8814033395439a6cb9c93b9a8ed4977e1b4618fd53d9cbbc73ec13e2f5561f7990ef63add918f4bc8aa3170aa80c09a8d5bff96f40aaed323841a7a16d0a30ff9adb62bdaa4da88161823bc02deb63537eca109e7b265d71fc3c11b33b06125f70c0680e0fe974987cb1048ffd405e92f16ead941f4d41f457261931363f801dfd0d54864609bab19510d0741ab8e0b2f1307468110bb6172d068f5adff0ac5b775dc9aa9e436b7f24f8b19196c0e3fa7ef0dc683ab4a4566f68f0211955d333e96d147694be384eb63c4ad9c717a6c9112c5190b5367382198539e8c811044b5df00dabd8562f056b677510159a7a3bed5da2e468110a9de4981004cf848097238441ab95df2dc541c6966e9fa9dba1a05ac6fd04ebabb7ca6cd17d9111577fbda68812da8e635caa414e983b102df97863910e1f6ad7c746dcb9516dc6e3b73cb56ae30d1ba3385981d6b03ecb1fb242c56e9abd7b786aaba8ada05c519c221e8487efa1c97af98ba7c6001bcd5ae7d0041984080bf0f81382728cef8dd9edaadbf3f0207e14090aca8d4aca80c7b3e19c1e6149b31c6c41d3dfe7fcf655684cad74438363c60c328da71d23910655953321c63985735acbb0efd579c2176f5038a53da31bc1f2465e8a187ccd7d30c9a9454cd42d211d896424b77d2a334df43a66adecba421e7c7ef8a1ae86c0e3299295e4cc0287d1aa1a73dc883b748287433fc06a591ca47a5394a2fea414c4a977d035dfedc01910a24bca2ddd16b630a0517b29a185e0b153313963ef89185e5425c1eedaf0c948c46e259b822818dccb8fa643c42ff9486e4e4fb5d119e6d27d56abaca181129c51df4e693168f4cbdcfad722aa3b4e9d1ccf6ed8649799d11cf5a76e4bddfb078bbb9bca9cb174abfd1c9980b6bbc33f76819203e4429d2edb0c3fd4bb01f26f642681b734a84d1ec43cc91247503dc0b5cf09f4f0a931846d6dee873ddea950f7423a3d61a26468403b38d5e2316c26184c842afd6c9463d9f0202cde21a19ad4c7fc0cdb8b446eb9f97c5cf0e47342c178667de95fb6f1efa8477ebfb239ed74d0c34dee1940ff96ed172ff027e41755912ced7aaf47f8b0adf76ad401937dc2fd600fef140a47ca8eb18a90ddbc55d51307d015050a4705668aad66f0d2d420c2ed695aba786d6a1344f5d0eeebce30e832c69e73ab5619777198bfb3c545901ba31b37c4eee3dd1cf26feb355d845e8c7d187acfc8cdd9c09d634cfc755d86b58767de0acd92edabb9ae8680569ff04360dd26e03a5bdcf44de3b25f7df8d3f3745e627dc58c5791426ed50fceea2ab69dbacec2a40331d9d5b4cba374b8404ce66e603d74c5185dbd2ece18586dc3283d0ae2a67aeaf918f9ad229c65db8301b25570e33273ee108ed28227e3ecb8588ea86ce04541d5eaa6781abaa20ce6c7c822440418bd70b8aaa10cafb39a3b38bc3df62abf4741c12ba3490276e93e1669d29bbfc9f23de7b2a80995fc119816e55a5baac09d03d4f8dc32249942c5591ce42056eefa130ee7332ee1f0ad685b669fcfb626b6927647e697ec63d3cb141f87713c73b8c5ada4d419493587843a3773ac3d14fee7abfdacb5fdb0c86947f1678f2be30b3a124e484f70f6b50b5e85f9147cda2732b918edc96a512c21192170c1f14492c2ade3e6d87648ba0e8347bdd5a0d996908291489611eb85b57fbf86e351e873b4ea9cd1d6c06aa7b361165b499af5a27d4e1be2ef4195cbf46e7de87cd83029fadf5aed2701d51fd0fd80492b1a0c9e173abd238eadcd79254eadb49c58f69913cb436b75966e9c5f8c1adadc70389a0fe4f78e2a09bfc1c510297ba5c2933deda0b3b447a86a709961c654669a0a6ca8cf5d7b69d70ea06149734232725bc9845fb482969c51eca24c722398e80e25085ab26e1a001d7a09c08c2ee18f8fea24d19245e6c3078eefae67091213322bb276305d4aea32c1cd703cba4a90660864928c46332598415f0f4d4ff9a0503a6d501d7f1685b404991f726b82d98856ad07fec7feb55691ea4e7a631536eb70b6c7edbd71ac5de3f1465f484d0ac0559697dc1caab8b0d391984de6344a4ef2dd95e9c96609fa58bdeb8b8e8f761bd1da31a03e73c7509ab6b476dc9b7e2a55afe727e6f23d65c3162591fe7802ab0c7007102ef4c8b63f324833804ba0a24c447ae8987a930027f340055c62db134e0c55d16f26033e0014e3d376ec980fd195da08c3f73f8d4fee50d30f0a3122fbb4603639db4f5b2d3c1d3b0daa711a732ca5b287597b7ae44911a9689584ec0ddac37800709807a29f1a2112521d7c95d41268014cda26c482d6d6e3046ec8a224b6955303f396a8ff09c9c18beefd4c1e3abfbd150f4f910a156121b7d34760d602c38c9034a790825f76fe92957a9a8100303387e028cbab1dfb45860f35406c0f55548c936666f017c85c14b2fc9c41074caeca997e2ccadf0673dc4299edcfbb75873084e029dfa9b7401a168eb8e876535349749b753a704f25ee25b905d3ad13d51a89c1aea335fe0032b4301dcef53b641502ad88ed1d2bc862c463b6049bee638584a8f362bb8c0bababa0e5079b31721155ff9780be8e141cfd22ff28743a07be8447dab0ca2e1ab253efd95c8f18c7ce20f77be278b076bbb35522557d1cb797ed3ca26abbbd8e797173efa0ad633ad2d34b364e6c1cc97a9195871b8db97cc5914b97cfcada3d01fb579dd92c0f227dc67308d0346ef66308a67f549706c20ae78ca165cd37659b9f008d666dbe32385b2c0ce5b7bdd8a7d07db4c6e4487da88dd51b406adaa9973512cf5a73ea2f497822f4ce1d37c54a07de8c27c214e87128f12e5d1da2f41066d9b345a030bb448fc216b4fb08328de427f8042c84663a0209a000a847d534c615214492bf06c771e9914f3412c2925b06a84f1e5f542b8a87519e5bd86059c67e13ac48d1412b2e6ff6065cd8fa74fa35b709304ec479a46d928e0d5c605219cdb55fd0a49026ffddcbdbf3c4f22a15b99e89a38bfaff6f1f1ed1d105cd3069243aec50c2c6c0c44f94ec948ed7f890d01b72fce7194ee1fc049bcb8af4d99e7a58b62c566d67950a4411eb28cef7af760081f5b7d3acabec1e1aefe51e98a9306db32b32a8bc96a5e5eac22724752cf56328c6cb44a263435cf600dc3676f0be3cad316fb9c5aba5322bf58461bfbe2d6f803a0eb2f44e7c74e8eb97e5e4073dd892947e99bb52f44ba31d97f02a7eb395ca2b3d0cf482545475b4ddadb4cfe55602e5b1765ded8b4ba0e3254021d77ffd02ae9e667b971e54ca6438194504f8b6b1c7cc35927abcad25a5d3fd7859afa4a67ae3841c78be5a8af464990f64aa1ea449a7d18b1ac7a25013a80117e5e6a1c83d53bad607dc211fadabfa23fcf6cf429a867ddd904dd0d2fccd5012cdf809509b1a7b02fc584fe303a36cc7075a6ab03dec671d6c5a7635007752e517bb2c6f8f293bf2d22cbf3f7f57c38b3edbf767bff86072139d6f8e225a21a46316602de1208e6f219f011d490f8f2d1be36490f7f2d8e9df105d000d44b57dc71f55eb342d21c880d41481671d3b420d7cc96eb879356839e0eea8c83ca43407f76e849b39403bcfc80349b8e48b499775a362da72d91104c48c022da425fa23e7cebc39c3ef117eb976c5e4ba6ae20d34834fdb1f1ae327a1702f42b78ee9509557fc03ce40a8c2a5316979d89c02944dbcdf40800f6a8a3688a62ceaf512ce4c90e04b08835b75275d93ee5bea22ea48a64a60fe6ff5f72f95f6a3ec99ff1e80eead731102b09d42b9d21b27ba78e8528bdac1d3ebfb71b750aa19184048ab09be23e0c3464fc1b9e5a874294476a2f058f52b1d401891bf410cb115a044d9f6c8797d549dea2af53583156c60e380c5bf950f41712283c2d0add7ded2673170adbbb36c19ecf942b67897b322595745ffc754793d4e0b5174567fd02ba736f8646679a2ad0e8bd3a3aef4b7b88cbdd8a275252e772c6ffcbe146bd8731323695b2c1fdf33ab8334b60b97ebde91bfe9aeedebff2f9ffb801cc60900fbfefff6e6f176d0833d3062041fb67dff1089a335d62068b95f129553d032115eb55fda40467b6a676433de4692178f88e4110064d00d58031babe081b96fe95ab56e661513a4e912406567a6db90044dd28b55329b7f29ec8a218c6e17d08627b16cef0c8b41c866e51cc4d2045f10042b109ae5061d8cc21b308bd1937565ab4ad8f99bee863cfd5c722aefc283bb6a666e56f2b5fb738ba4c4209c7b362bce3b7a1a6a20e11c3bc7a16dafef12b0abdf929277f5b88f57a15e8a91690df9a1c991e54d436a7830aecda8d9507707503eaf81280118978df8dc17e829868d4403ab69da509eed00fb21520115924e2286a8ca84328f1d1a16d3cab8c77aa23942bd4d6fa8f2df462f5832f4fce8c7dc141bbb227bf66a4a8df8413f48d610b2a4c19f463e29b4f26d1403aac5e889d947af7671c12447236fb7ce033c1598cfbb9f44d081b1e34b17b3cf0805130af2e8a3478cd0cf10057645ea3d7d9c8ad63ca54f54251b320014a96c6df42708ad1efde0a53e9adbf3acfc630992382e5a3e56fb818b860b8f9661465f721d243f55f3c0b4a65748564d44e3db2200c85ad1b9fa98ce2329db45dce58a77273e68447726364204cac8d7a9dccab4cb0c33f7a6f48681eba8b5a1f698a722301378bcb32b9aed8a8a00134462e382038a082f69c4c8ab43ee7462b1212a11cd19ddeca3e3ac512cb4dcaebdef141a73b2649c58020401495892a9f3686049ee8c9dbe1b45768e9cf0ec3c945d7afcf9824a0652c4e8e9585fcf5d228146ea52db99d0e700a3c2961f59528020df13b6ffb4a47e3cb85be418aab4e4beec48b92d1a7a2e89dc889fb27ecc51dbbe67922d50970bacc80cad46402409ac9ae72927d0e7aa4d1686c31a6bad44e3987f26d57607c827bfdfe23320964395d2163cc1c7d210308819f04141ae19b7e58fb0196a95f3e85759285e8ab4cb890832398efd7a210e318fd0fd2d22f2daee082205183aca5d5f3519572eb9d1e9c52af1ee513cf5da315c0725f979fb9d802052bb60587bde14fbb0a0135d69ce2e6286aad99c8069f7d4984bbebb8e0701fd24971b978a1b27caa0889fc27c79af5d593841244ba4c91610ccb7a5ec63d60f505f6e62bf14d0da6917dba3336725c63e033f065e5f3d6497ce2df848564e93881ae8d04f10f3c9df739fe15e5aad625554f4d8df28794bc09e858a29986855354c3ecc6eddc76b41bb299fcdbab69d64d420a5afac01d237efe2e48b1590446e4db8d7a587f5f7d917166e3ebe3014fcb33dcc46d626f38c3bb63bb2cc20a30bf64242f95f05c94417fe740191a58dfe06ebebfba51231553104e6026d500c707bcdb882812846aee83209ee88fc8b7b37a5129b93621987cd77145831b28c2715ae49c3b7fe09f88b09f897b18b83dc0a1022669a9989ccd125b3d912b7ca9d34d26562c84290c8331aa7a87f1f957c3c7eddd1906e7270386edb6773b284268a03b44e4f9fb192a65868a84985fe26358b203d4ac6f8ffeacb4c8f78fd939d384fd6d2adaf522f50aa22a90c195b0133871cb4e662a9324f748cc4ae2ceedae46e90c5ee77e9aea2d480b18d9a840fca567ccca8945ba5ccc2c136cfe278b33728be36db1f9de6200298f1cd75c8b5a80ed3d8c04801191e8aa250468a61fe0ac7bc3cad2b2db788733c167865d730e290506cac71d988e913669ad33c26e349a4822afc38b21f7fe08000bfd63c7d209617b05658278cb220b38ad2528dbe8dd681aaab85ea806285cde04e3433392ed5d7ac27c0a08c7a5ec9f748b45c3a94593556258f0a2f9f1e45b9824ca7f683fd1864ca187d2ac6c145986c2755cbae4d441aea9706ba451f5c506546fde65f6e263b996d6ab133514a27519b3786d135ad5b1eaa26ef4a7c2c82857f4afc3219e446a6b72efa89768286e119b61e035a0aa7d9b68a33eab4be704a2f1d553bba18d8e2a8c84da78b84c449dc77f7c4382c17aad3d8af1c2c6f532fc68c42dd54c62c65a3dc08ca84f1939042799d89f2a2dfbc59d7c9d8bbc2ff9d6c51e0cf7a3eb1af56364cf53a3ba079fa5af81817a9128db3ef66ad9e58b6001218519acfeccbbdd20ca1bc19fc7d26698123c71f6a15590b3d52fb73d518e5254626565c82fd18d55ebc63a90da746aae2b3eb0a7e86f72f2232d9d6b63ac29fd3317e7989da79f5187d8d5bd2901836716b205dced5eda5f00ae91daa8f8be8241ec82182e1c5774157fc437829faf3144828bee91602ed076f0f19139b0aa572817d7a2117b46cf2d1cb06ee6b00825b3fa18751b5a68418831f1391aed8dfbe5bdc38468193b95eed99dbb1ea3fdb77586edc5f2b75446ecd423ade60b57f3c4baf91ec2c17a9f004db6d7145a0d20ad060f1d4bd4effe053b5735bc719c41b4b4762d1fdb97a9233ece6f420348aaab748668326c95e97e3ed96235371c4a65ff9d56873cefe3c2370c7e8c4be8b0f66b6eb20c0e97aa01f38474c7dcdc4f47a706069444dd221e350a28eac3da4d91904257441fb30a683cd6815ea12834ad4fdc1d238fede20cb618ba94021616f7db99c731df7ffb54e7a7992a9cbecfeccd3dd07f665ddc3e1f0b18ac032abc9f1e197ae99876fa4092a3b28dfb1e0ef4e8983aa8ff9440909b21e718802484f49e39c7bd3f440a11a8586a5858c9e5b7b5d8d6ad677a23a6581d59132333505d7be786e354279bb4070f58bb29ae506a3bbe5e7d1bbc702a54fe8b48ca0f93f5f19516362aa3841909083a696be3a3f9eb72464566b9bc91b575ba74f33778af44ef90d0b4078c9ac8379265f014fa45eabb308dc10a08ad1e76319162d2d5ea6b2440dd91d2727f8fc7b102560de011cd65882560b5474c18fd0eac3e07567673c27ec3b73bfc453a7a44f6bff3dc283edd41e158edc923e55cb863d106251077daafdfa7036dd4cd4cfa0d74754c8c89a2099aaa706e3c9e49c861b1bf61a385dfb852a51e6eb091d82445ccbf6df587f1ebe933c28bacfc107019435061186dbb20f97c8b93c6c0a02fe69fab8fa6f0da47b06a0c75da718d6675372693ca16df70ac69f42a181cd61543e9c33d7bb124aab180537f02368a3db64453de923ed9baf4ec89fbcb1e31bef2bf56390faadc4f4a106e5bba3bdccc17c0b7128284e5a09862a98be956bbe568be02742025e7be9e2cff67fb5c28fac2e3fe1ebb11ca4852e2e84d2800bdd4fc5a259c6526fcf0c83a9a3054752224318e8c7a16c4f2968187e61974dd39c91963130085bcb8cda9223048cf60474c64bb6d6272f2ecc0a55d90ea1a1dc7269211a125d7c7edf4d3f836a0ce3203f9d2804de016f2d75310a521cf34c3d180713f799b0b43727a3bb2160f2013eb3d7168e83f2e0d41f886d2cb20fd0f69be80f1cd5ec7bb2b11a407fe215f2f19e75664aaac2424f9429b36ef02a8d77a000ba81df641554ad5d11b6916de83f6bef568e80282b2573c95b028a28b0ab2fc3700a08d5968fe55effd88c3f80493fc5f2b550977bb21d15bd72a70d422d Password is required.","categories":[{"name":"未分类","slug":"未分类","permalink":"https://blog.ryaoknw.site/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://blog.ryaoknw.site/tags/%E6%9D%82%E8%B0%88/"},{"name":"private","slug":"private","permalink":"https://blog.ryaoknw.site/tags/private/"}]},{"title":"10月追番锐评·兼年度动画排名","slug":"10月追番锐评","date":"2023-01-24T11:50:14.000Z","updated":"2023-02-17T21:20:59.814Z","comments":true,"path":"2023/1/72c99cd69d60/","link":"","permalink":"https://blog.ryaoknw.site/2023/1/72c99cd69d60/","excerpt":"","text":"前言懒得写但又总是想写，于是便随便水水罢 本来还打算单独以一篇「看动画破放了怎么办·尬黑·孤独摇滚」来作为评价的，但是懒，以及感觉怎么写也无法准确表达自己的想法，于是也随便水水罢 2022年10月电锯人 stars：7 中山龙拿着电锯人ip的红利追求所谓的“电影感”，最后做出来的东西实在不太符合期望。 可笑的是吹的几话都不是龙哥监督的。 作画水准实在不敢恭维，一堆异样的走路摆动幅度，极其粗糙的长镜头运镜，是否搞错了真实系作画是个啥？更不用提各种谜之演出，战斗节奏说停就停，还有一段意义不明却占了几分钟的清晨生活特写。 期待龙哥的后续发挥，但他实在不适合来做电锯人。 秋叶原冥途战争 stars：6.5 PA原创动画 套着女仆皮的日本黑帮故事，全篇充斥昭和味。 在看完前几集后，黑道女仆的噱头意味已经淡去后，本番本质上是对黑道元素的利用，用极其荒诞的展开以及一堆女仆元素来展现黑道题材中的对于无意义无结果的认真与坚持。在荒诞背后透露出悲剧，而只要将这层荒诞稍微减弱，悲剧色彩就被无限的放大。 本番剧情的展开十分严谨和自洽，在每个荒诞和反常识的展开背后，都有前文的伏笔作为呼应。 动画逻辑的核心是对「女仆」职业所抱有的“认真”和“大义”，这种坚持与大幅度流血与牺牲形成极大反差，体现出「无意义」，全篇都在以一种荒诞的形式来讲述背后的严肃内涵。 但要说内涵，实际上除了从9&#x2F;10话开始的正剧，到最后岚子被杀，我只能认为这是一个“形式”大于“内容”的作品，就和上季度的孔明一样。 不过就总体而言，这个原创还是给了我不少乐子和惊喜，极力夸张的演出风格与其背后的荒诞为作品增色不少。 我极力反对那些在看完噱头图一乐后就抛下一个“逆天”，而在热情退却后写下一句”无聊“作为口水话来评价这个番，它其实是制作组的一次用心的，充满诚意的「单推」 机动战士高达 水星的魔女 stars：7 大河内将重新定义高达！ 大河内携手高达ip，将其打造为现代的，符合当下主流审美的高达味。本作抛弃了高达一贯坚持的宏大叙事，从校园、百合双女主以及融入其中的各种要素来讲「后退只能选择其一，前进兼得两者」的主题（当然，虽然还有一半没出，但是专业的动漫高手是不对其抱有乐观预期的） 值得一提的是ep11长达4分钟的调情演出真的太精彩了 总之还行（至少我认为整体比电锯人好看） 恋爱FLOPS stars：6 以故意典为卖点来消解因为典带来的烂俗感觉，脚本安本享，著有石头门混沌子等作，是5pb、mages的脚本家。 由于脚本我可熟了，后面开始“神展开”的时候也没抱有太大期待，从前面的水准就能看出不太能期待，以及对5pb等作一贯神展开背后没什么严谨逻辑支撑的了解，最后失去了典要素为卖点后，本作也就没什么意思了。 附科学妄想经典番茄酱： 孤独摇滚！ stars：8 值得逐帧去看的萌豚动画，制作水平太高了，动作细节设计的太好，改编的部分也精致有创意。 太厉害以至于我唯一能想到的尬黑只能是原作自身水平，我将化身成为cloverworks厨，这是今年给我最大惊喜的动画，它甚至只是芳文社漫改。 演出形式又新又整活，以至于你能很容易的制造各种题材的二创。 制作团队厨力拉满，以至于作画演出水准足以让平凡内容焕发新生，喜多厨头子けろりら天天在twitter高强度摸喜多。 这样的高质量制作暴打10月顶级ip电锯人，本来7月pv出来后，我只是因为有长谷川育美（明羽杏子）才去关注的。 那么介于我对这样一个动画的喜爱，在看完第12话后我不得不去关注它的缺陷，这也是为什么要「看动画破放了怎么办·尬黑·孤独摇滚」 我对结尾充满了失望，它不具有任何冲击性，我所设想的有那么多人的帮助，并不是说要改变社恐，而是至少可以去展现波奇的心境转变，而不是依旧因为简单的理由（譬如最直接的我喜欢音乐）去对待摇滚，这不是君に朝が降る。在bocchi the rock优秀的背后，不可否认它对于主角的形象转变的刻画是非常乏力的，不可否认的是不管怎么解读，这一整季的成长性是欠缺的。作为一个动画刹帝利，在我的观点里，波奇的所谓「社恐」不过是一种标签化的展示，一种夸张的舞台表演，一种将笑点合理化的说辞而已。因此在最后我将尬黑为：「毫无深刻主题可言」「对社恐与他人的相处方式表现失真（对平民与上层阶级关系表现失真）」「缺乏主线连贯性」，这一点更适用与另一个评分高得离谱的动画「辉夜第三季」，只不过在那里更看不到什么批评之声。 契约之吻 stars：7.5 A1的7月原创，本来是准备专门出一篇来谈谈丸户史明的风格以及其脚本设计的高明，但是感觉能力不足以写的专业全面点，于是作罢。 典型输出角色类型的番，实际上剧情不行，但我太爱了，star+1。 追番体验远大于补番体验的动画，每一集都有新乐子，要去深究，剧情其实漏洞百出，各种作画和演出问题也可以单独切出来批斗批斗，为什么有这种好的观感，得益于前几话的提纯，以及丸户脚本抓住人心的水平。 cv会泽纱弥的声音可太好听了，表现力拉满的同时还带有涩气，1月的生而为狗的表现也很好，这种cv可以期待一手同人音声以及套马甲进军里界（简直是至福） 年度动画top仅评价8分以上作品。 1. Cyberpunk: Edgerunners极高的水准，trigger拉来众元老，用行动告诉了业界依旧可以有着20年前的高水平。 啥时候养老院khara也来一个原创（ 2. メイドインアビス 烈日の黄金郷双线叙事编排精巧，跨越时代的冒险被深渊的罗盘所联系。 深渊是工具，将一切现代价值解构，将人从「有机」转为「无机」，“天地不仁，以万物为刍狗”，在深渊中，人变为了最原始的生命形态，在此，「一切垃圾都能变成黄金」。 通俗意义上的生命不具有「价值」，愿望获得形体，意志化为肉身。 痛みと痛み取り替えよう糧にするんだ 落花のかけらすべて傷ついて僕は象ってく 形になる目覚めの先で行こう ずっと 響かせよう 3. ぼっち・ざ・ろっく！在进击的巨人与孤独摇滚中纠结，由于在写这个的时候笔者已经玩过muv-luv了，对巨人剧本有着相当量的不满。以及笔者向来对厨力和用心有着情感倾向，于是决定还是给孤独摇滚吧。 4. 進撃の巨人 The Final Season Part.2mappa尽力了，而wit还在用古桥一浩x间谍过家家这种答辩摆烂 5. かぐや様は告らせたい-ウルトラロマンティック-演出大好，4月最佳 6. からかい上手の高木さん③只要细节和铺垫做到位了，即使是普普通通的展开也完全可以在制作工业化的时代做到乱杀，单集亮眼","categories":[{"name":"动画","slug":"动画","permalink":"https://blog.ryaoknw.site/categories/%E5%8A%A8%E7%94%BB/"}],"tags":[{"name":"动画","slug":"动画","permalink":"https://blog.ryaoknw.site/tags/%E5%8A%A8%E7%94%BB/"}]},{"title":"通过手机USB或者蓝牙共享网络","slug":"通过手机USB或者蓝牙共享网络","date":"2022-10-05T14:22:47.000Z","updated":"2022-10-05T14:38:17.332Z","comments":true,"path":"2022/10/ac2b91736516/","link":"","permalink":"https://blog.ryaoknw.site/2022/10/ac2b91736516/","excerpt":"","text":"才知道能这样。。。简单记录 USB 手机打开“USB共享网络” 连接数据线 ip addr 或者 ifconfig 查看是否有新增网络接口，如 usb0，dhclient usb0 分配IP地址即可。 不出意外会在有线网络处连接上手机网络 蓝牙 手机配对系统蓝牙 手机打开“蓝牙共享网络” 在网络处连接即可 成功时网络配置里长这样：","categories":[{"name":"未分类","slug":"未分类","permalink":"https://blog.ryaoknw.site/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[]},{"title":"葉・锐评莉可丽丝！","slug":"lycoris评论","date":"2022-10-02T21:15:50.000Z","updated":"2022-10-03T14:21:03.621Z","comments":true,"path":"2022/10/6a26be0842f4/","link":"","permalink":"https://blog.ryaoknw.site/2022/10/6a26be0842f4/","excerpt":"","text":"莉可丽丝 stars：6.5 开播前以及开播中都期待值拉满的原创动画。 在看到pv，以及看到第一集后，对画面质量的优秀、主角动作的精细程度感到十分惊喜。泷奈的cv若山诗音是老熟人了，新届热门cv，事务所也在强推，倒也没太喜欢，但是千束的cv安济知佳发挥非常出色，完美表现了千束的活力和元气。本身我对具有百合气息的番表示极度欢迎（谁不喜欢看美少女贴贴呢），于是它成为了我周六更新第一时间就会去看的番。 后续剧情槽点很多，不过制作组重心依旧不在挖掘剧情设定，倒是关注于女主角的神态和动作细节上，每一集都会出现的清新日常画面也让这番大火，切片都能上抖音爆款。当然，这挺好的。至少，前大半部分精细的神态动作，以及足立监督设计的场景让整个番的贴贴场景充满“日常感”，值得一提的是，bgm和ed的插入也非常精准。 制作组专注于“日常”的部分，而有意淡化lycoris背景设定下的黑暗一面，其实设定部分要展开黑暗面、挖掘深刻内涵，可以写的东西是很多的，比如lycoris的诞生，DA组织的实际背景，旧电波塔时期的事件等等。淡化这些以后观感是很好的（至少对于我来说，我是吃这一套的） 而在第7、8集开始，从千束心脏的设定开始，莉可丽丝转向了更深刻的故事内核（虽然它烂了，但不可否认的是，它确实有去尝试表达这些）： DA机关培养着社会工具人lycoris，泷奈也是其中一员，他们从诞生之时就被社会赋予了社会义务。 lycoreco咖啡作为一个日常的场所，而亚兰机关和DA组织作为黑暗面的部分，二者形成对立冲突。他们各自代表一种态度：前者作为一个日常的、有生活感的温馨场所，而后者追求将每个人的天赋进行开发，让他们都去执行自己的「天职」，即使人们不再信仰上帝，但是依旧为了为了这种「天职」而追求，以此来感受到自己的「人生价值」。千束作为一个亚兰机关的孩子，而在lycoreco咖啡中生活的她并不愿意去履行这种所谓的被赋予的社会义务，而是只想做自己想做的，守护自己想守护的。泷奈在前期也对自己在DA的生活方式有着强烈的执着，觉得自己一定要以执行「天职」的方式才能感受到人生的价值。直到她遇到了千束，逐渐被千束贴贴影响，这种观念才有所改变（从这方面看，莉可丽丝其实也算是一个很不政治正确的番，很明显它是对选择在lycoreco咖啡生活的千束表示肯定的，同时对DA也有明显的讽刺）。 莉可丽丝所想要表达的，正是对放过「天职」，放下固化的执念，好好追求自己的幸福的生活态度的肯定。 题外话：所以说现代社会对人「天职」的要求也逐渐成为了人自己对自己「天职」永无止尽的要求，有时候部分人确实得想想，自己到底再卷什么，说到底最终能卷离自身的精神虚无吗。 正因如此，我在12集前，甚至11集时，还在期待更多，期待它完美落地后我能直接吹爆，但是12集直接让整个故事变成了喜剧「乐」 那么12集以及之后的13集到底烂在哪？让我来仔细喷一喷。 它的剧情逻辑过于扯淡了，这一点实在不用多说，只能说如果制作组觉得日本人的脑子是这样的，那么能想出番里的日本人这样行动也是挺合理的。但是其实也能接受，因为倘若仔细想想前面的剧情逻辑到底如何，大家心里应该都有点数，只是这集尤其逆天罢了，这么一想日本人的脑子确实是这样的。 在我看来，真正影响观感的，是整个主角形象的彻底崩坏，以及故事内核的彻底崩坏。 千束，作为一个故事中最讨喜的角色，为什么讨喜呢？因为她一直作为一个坚强、自信、对任何事情坦然接受展开笑容、遇事游刃有余的形象出现，但在12集中，千束所展现的只是和吉叔的一顿嘴炮，以及摆脱了杀人机器的「天职」，而被莫名其妙的“不杀人”的新「天职」所束缚的形象，她的行动根本不是对「天职」观念的否定，而只是被另一种形式的束缚了而已。而泷奈和吉叔两人，一个“心脏要逃走了！”，一个“来杀我呀来杀我呀”属实逆天，这就是你足立眼里的对立冲突？ 而在13集，千束一顿操作后依旧没有解决自己对于「天职」观念的矛盾，制作组而是换了一种方式，“诶，我让大叔把吉叔杀了，让千束开个挂，这样千束不就既和解了也活下来了嘛”，属实在原有崩坏的基础上更加崩坏了。我在想千束在lycoris战友身受重伤的时候心里有何感想，一枪一枪打向绿毛的时候心里有何感想，泷奈快要被杀的时候有何感想。惦记着不杀人的想法在电波塔扯淡，难道被肃清的lycoris的命就不是命了？难道被杀的恐怖分子的命就不是命了？难道被大叔杀了的吉叔就不关自己的事了？ 我不理解，为什么后面要突然去讨论一些不属于自己的话题，明明不需要关注杀不杀人，法不法治，这单纯只是一个触发矛盾的工具，只需要简单的，实在不行弱智一点，机械降神的解决问题，这样千束依旧以全能洒脱游刃有余的形象获得所有人的好感，剧情弱智和多余未回收的设定是贯彻全番的问题。于是为了填这些，再强行加上逆天设定。只可惜它还是要去讨论不属于自己水平和日本人脑子的话题，最终主人形象彻底崩坏，内核崩坏，而逆天的剧情只能让这个番配上一个字「乐」。","categories":[{"name":"动画","slug":"动画","permalink":"https://blog.ryaoknw.site/categories/%E5%8A%A8%E7%94%BB/"}],"tags":[{"name":"动画","slug":"动画","permalink":"https://blog.ryaoknw.site/tags/%E5%8A%A8%E7%94%BB/"},{"name":"评论","slug":"评论","permalink":"https://blog.ryaoknw.site/tags/%E8%AF%84%E8%AE%BA/"}]},{"title":"葉・赛博朋克・简评","slug":"赛博朋克评论","date":"2022-10-02T20:20:06.000Z","updated":"2022-10-05T14:24:04.190Z","comments":true,"path":"2022/10/cba225035484/","link":"","permalink":"https://blog.ryaoknw.site/2022/10/cba225035484/","excerpt":"","text":"赛博朋克边缘行者star：8.5 由于会讨论“赛博朋克”这个话题，为了便于区分，我姑且在文中只称这作Cyberpunk: Edgerunners为“边缘行者” 赛博朋克在如今看到的大部分涉及未来科技，新颖世界观的作品，它们被标榜为“赛博朋克”，但实质上大多只有“赛博”没有“朋克”。 赛博朋克本身就是对未来科技发展的一种悲观预期，对人类未来可能出现的社会形态的假设和探讨，它会对现在社会的传统概念进行解构，展现出一种颠覆性或者叛逆性，它的整体风格一定是反乌托邦的。边缘行者在这一点上做的尤其好，整部番中都始终展现出一种无限压抑，无可奈何的氛围，整个叙事氛围都笼罩在对于赛博社会的无力感中。 在边缘行者中，在夜之城这个赛博社会中，传统价值被完全解构，人们的精神价值依附于金钱、肢体改造、以及幻想物。这一点在第一集的诸多细节画面中有着较为详细的展现。 大卫在这样的一个未来社会中，大卫，作为赛博社会中的一个普通人，他在赛博社会中的精神虚无，陷入后现代精神危机。这一点在前3集中就有集中表现，比如母亲死前，即使自己对于当下生活感到不满，依旧没有表露，跟随母亲的心愿上学；在母亲死后，自己不知何去何从，然后出现一个镜头，大卫从高处跃下，落在垃圾堆。 直到被一个成熟涩气大姐姐lucy捡走，从之前和母亲相依为命的「群体」转变到了团队的「群体」，依旧在其中继续迷茫地活着，然后在团队中被Maine认可，被lucy认可，也对于强大、经验丰富的Maine心有崇拜，这也为后续大卫继承Maine的领导者身份，追求团队工作，追求自己的身体改造做足了铺垫。 直到Maine死亡，大卫的精神状态被迫接受了转变。 前三集直接让我不得不熬夜看完这整部番，充满光污染，高饱和的画面，无处不在的社会和民生细节的刻画，让我甚至需要暂停反复观看，完全没有快进的想法。第二集被lucy带走，以及拉去月球，整体演出表现高涨的情绪、癫狂的浪漫主义，在夜之城的这种疯狂中，更是进一步衬托了赛博社会人们精神虚无的现状。 Maine的命运其实也是对男主命运的预示。在夜之城这样一个赛博社会中人们作为社会工具，无法逃脱体制，被夜之城操纵，精神除了追求身体改造没有别的出路，直到被折磨至精神疯狂，在被彻底混乱之前挣扎，然后作为毫不起眼的死亡体验素材从社会中消失（吉米的大量摆放的素材完全突出了这一点） 第6集Maine之死的演出实在过于优秀，在最后一幕中，静止镜头配合强大的蒙太奇手法，配上嘈杂的噪声音乐，一整个就是极致的暴力赛博演出，实在精彩！ 后续故事讲述大卫精神危机所导致的恶化，在第8集时，变为了当初自己讨厌的那类人，让自己母亲身亡的那类“走狗”，大卫在团队中迷失自我，无可奈何的走向崩溃，直到在最后一话，在极致癫狂的精神错乱中，随着Rebecca的荒诞式的惨死，自己的生命也走向了最后一刻，最后那仿佛释然般的一笑是为何而笑呢？ lucy我始终认为lucy其实并不是边缘行者中的主角，她和Maine、Rebecca等人一样，在这短短10集的动画中只是作为一个故事工具人，这也导致了我心中的遗憾：这么好的大姐姐居然没戏份？！ lucy从前2集就抓住了我的眼球，一个成熟、独立、有经验的前辈，一个帅气潇洒又带有疯狂的赛博女郎，而在第2集带david去月球的情节中又表现出lucy讨厌夜之城这种赛博社会，向往一种在那时已经被完全解构的传统的浪漫、自由与解放。（多么好的涩气大姐姐，很符合我对赛博女郎的想象） lucy和david其实有着相似的悲惨经历，这也不难去理解lucy为什么会在短短的时间内就接受了david。 后续david死后，lucy一个人去了早就能去的月球观光车，没有自由和解放，依旧无法逃脱赛博社会的压迫，极致的悲哀和无力感。 让我觉得不满的点在于，lucy在接受david之前，也就是我上述所说的一个独立的赛博女郎形象，而在后续情节中，尤其是在Maine死后，却直接转变为了一个为了保护大卫而行动，以及等待男主角拯救的传统动画女主角形象，而在家里更只是一个相互依偎，让大卫搂搂抱抱的“居家贤内助”形象，我本以为揭示lucy的身世后一定会有更多的转变。 确实，这样也问题不大，只是我觉得可以更好，现在的结局只是：david死了，lucy依旧没有获得她想要的自由和解放。我觉得可以有另一种可能性，譬如大卫在赛博社会中不知何去何从，陷入后现代精神危机，而lucy向往的是旧传统的浪漫。可以用浪漫主义解决后现代问题。 不然在第2集那个经典的在月球上带着david纵身一跃有何意义？ 吐糟其实这作一点都不扳机社，可能唯一符合扳机社风格的就是Rebecca了。（没想到trigger居然有这种水准） 有人说david的一生为了别人而活着有什么不好的，确实，这也是一种典型的生活方式，要多点篇幅刻画其实也可以写成“赛博士郎”（笑） 边缘行者通过多个角色的生活方式提供了一个多元的视角，在夜之城中，每个人都有自己应对人生虚无的方式，依靠他人而活的david，为了自己而活的Rebecca，为了オナニー而活的Pilar，为了夜之城的金钱地位而活的Faraday等等。在赛博朋克的框架下， 边缘行者对于夜之城的各种生活方式都有着一种嘲弄和同情的态度（唯一去表示肯定的白月光可能就是lucy的传统浪漫吧） 真没想到如今的日本业界还有水准做出这样的动画，trigger这波拉来了一大众元老人物做出的边缘行者无疑能成为今年最佳动画，在这部边缘行者中我仿佛看到了老gainax的影子（trigger真的很gainax），这部边缘行者的男主角david总能让我看到EVA中真嗣、FCLC中的直太、甚至包括天元突破中的西蒙的影子。他们都是在为一种无力感和迷茫感做斗争，挣扎于自己人生价值的虚无。但是david并没有想这些角色一样受到trigger以往“突破天际”的眷顾，真嗣有葛城美里，有明日香，有真希波；直太有春原晴子；西蒙有大哥，优子和妮亚。但是david却只是处于每一个人都有着深深的无力感的赛博社会中（你以为lucy是春原晴子？错啦！），在这样一个一切传统价值都被解构的社会中，david无法找到自己所应当「相信」的东西，只有金钱、肢体改造和幻想物，所以他最终只能为了他人而活，为了他人的梦想而活。 后话奈何文化水平低，看不懂很多东西，没法做出细致的“锐评”。 写一个这样的评价实在费劲，不知不觉就花了个把小时，其中还有一堆不通顺的胡言乱语，但是懒得审懒得改了，如果有时间和动力，还想做一篇《双城之战》的评论，这是我近几年来最爱的，丝毫看不到任何缺陷的作品（吹爆捏）。 推荐阅读https://writeas.xyz/zsn4p7dacycfy8e6.md","categories":[{"name":"动画","slug":"动画","permalink":"https://blog.ryaoknw.site/categories/%E5%8A%A8%E7%94%BB/"}],"tags":[{"name":"动画","slug":"动画","permalink":"https://blog.ryaoknw.site/tags/%E5%8A%A8%E7%94%BB/"},{"name":"评论","slug":"评论","permalink":"https://blog.ryaoknw.site/tags/%E8%AF%84%E8%AE%BA/"}]},{"title":"2022年7月追番锐评(一)","slug":"2022年7月追番-一","date":"2022-10-02T19:58:06.000Z","updated":"2023-02-18T03:09:28.421Z","comments":true,"path":"2022/10/cf556c178003/","link":"","permalink":"https://blog.ryaoknw.site/2022/10/cf556c178003/","excerpt":"","text":"前言博客老旧没动静了，之前还意外扬了一次，准备手写一个前后端自己搭建一个新的，上手觉得不太有趣，于是作罢了，旧博客由于更新hexo和主题导致不兼容，自己写的一些js配置全没了，不想再折腾一遍了。 无论如何，本来想只做技术的，现在发现没啥意思，不如在里面发发牢骚，平时追番完结了只在群里锐评一番，流水账一通说完旧没有后续了，而bgm的简评限制了200字，实在不够婆罗门说一通的，想了想把看过的番评放到这里来或许挺不错的。 2022年7月继母的拖油瓶是我的前女友 stars：5 厕纸轻改动画，水准就不用多说了，设定挺好玩的，不过制作组没有玩出什么花活，但它姑且能看，这番就好比寸止挑战，该A上去完结的时候给你停一手 欢迎来到实力至上主义教室 第二季 stars: 5 制作非常烂的厕纸，也不必多说，值得一题第12集，作为看过原作的人，单纯为了等路哥暴打龙男孩而看，制作组也尤其懂，在打戏方面异常精致，画面质量出乎意料，可谓是为了这点醋，才包的饺子。 夏日重现 stars：7 话题度拉满的动画，原作被吹为命运石之门等级，但至少动画实在不敢恭维，专注于叙事，而在形象塑造上非常马虎，大部分时候它所渲染的氛围与我心中所想的完全不同，尤其bgm的把控让我想要大骂。整个看下来，唯一让我影响深刻的演出部分也就只有第三集结尾追潮的部分。而尤其25话结局的演出，实在太烂了。 来自深渊 烈日的黄金乡 stars：8.5 布耶可cv寺崎裕香的表现太优秀了！不太熟的cv，但是从现在开始关注了。 第一季以及剧场版的质量也非常高，原作的质量也很高，作为第二季，整体质量很高，bgm质量很高，尤其重要部分的bgm的插入完美把控了情感，演出非常精彩。 双线叙事编排精巧，跨越时代的冒险被深渊的罗盘所联系。 深渊联系着上面的世界，与被诅咒的奈落的另一头，莉可在奈落是死的形态，在深渊上面是活的形态，深渊赋予生命的死亡意义，“不管怎样，我们都不过是奈落的产物”。在abyss，有机物不存在额外的价值，而深渊将给予「挑战」它的人们「价值」。 深渊是工具，将一切现代价值解构，将人从「有机」转为「无机」，“天地不仁，以万物为刍狗”，在深渊中，人变为了最原始的生命形态，在此，「一切垃圾都能变成黄金」。 通俗意义上的生命不具有「价值」，愿望获得形体，意志化为肉身。 部分场景的演出差了点意思，比如第7话，以及最后一话中有的场面的插入甚至可以说生硬尴尬，缺少了应有的震撼，或许也只是我期待值过高了。 ps：我尤其讨厌所谓的原作党，很多时候他们很大的影响了一个动画的讨论氛围，这也是我更喜欢讨论原创番的原因","categories":[{"name":"动画","slug":"动画","permalink":"https://blog.ryaoknw.site/categories/%E5%8A%A8%E7%94%BB/"}],"tags":[{"name":"动画","slug":"动画","permalink":"https://blog.ryaoknw.site/tags/%E5%8A%A8%E7%94%BB/"}]},{"title":"图片文件结构与PNG编码","slug":"图片文件结构与PNG编码","date":"2022-03-20T04:00:36.000Z","updated":"2022-09-21T18:15:38.948Z","comments":true,"path":"2022/3/7cad8c576e96/","link":"","permalink":"https://blog.ryaoknw.site/2022/3/7cad8c576e96/","excerpt":"","text":"图片文件结构与PNG编码图像存储颜色在计算机的存储 颜色模式 RGB色彩模式是颜色模式之一（除此之外还有YUV模式和CMYK模式等等） 在实际的开发中，我们可能还会遇到RGBA模式，其中的A代表的是alpha通道，一般表示透明度，值从0%-100%，0-表示完全透明，100-表示完全不透明。 RGB（255, 128, 196）：有3个颜色分量，分别是R的值255，G的值128，B的值196，这三个分量分别用了8位存储。咱们前面提到过8位存储，可以存储256个值。 关于RGB的颜色表示还有一种16进制表示方式，比如刚才的RGB（255,128,196）换算成16进制为#FF80C4 像素 每一个像素都有一个明确的位置和被分配的色彩值 分辨率（Resolution） 又称解析度，可以细分为显示分辨率、图像分辨率、打印分辨率和扫描分辨率。 显示分辨率：分辨率 4000x3000 图像分辨率: 常用单位，dpi（点每英寸），ppi（像素每英寸）。1英寸&#x3D;2.54厘米(cm)，它的实质是描述了图像的真实大小。比如“水平分辨率 72dpi” 图像文件格式 BMP（Bitmap）：是Windows操作系统中的标准图像文件格式，采用位映射存储格式，无压缩，BMP文件的图像深度可选1、4、8、24位。BMP最大的特点就是没有压缩（所以它的图像大小你可以直接算出来） JPEG：联合图像专家小组（Joint Photographic Experts Group，JPEG）是一种针对图像的有损压缩标准方法。使用的一种失真压缩标准方法，24 bit真彩色，不支持动画、不支持透明色。 PNG：便携式网络图形（Portable Network Graphics，PNG）是一种无损压缩的位图图形格式格式是无损（不失真）数据压缩的，PNG格式有8位、24位、32位三种形式，其中8位PNG支持两种不同的透明形式（索引透明和alpha透明）。 GIF：图像互换格式（Graphics Interchange Format，GIF）是一种无损压缩的位图图形格式，采取8位色重现图像。 图片的基本概念 位图（Bitmap） 又叫格栅图或者点阵图，是利用像素阵列来表示的图像。位图的每个像素都被分配了特定的位置和颜色值，颜色值可以由RGB组合或者灰度值表示。 位深度（Bit Depth） 每个像素用来表示颜色信息的位数，位深度越大，颜色越逼真，占用空间也就越大。例如，位深度为1的位图的像素只能为黑色或者白色，位深度为8的图像像素有2^8^（即256）个可能的颜色值。 颜色通道 RGB图像的像素由红绿蓝三个颜色通道组成，8位&#x2F;通道的图像中，每个通道有256个可能值，因此每个像素有24位可能的值，通常将24位RGB位图成为真色彩位图。 色深度与位深度 色深度：一个颜色通道的位数，单位为 位&#x2F;通道 。常有8bit、10bit 位深度：一个像素的位数 Alpha通道 在原有的图片编码基础上，添加像素的透明度信息，因为通常把RGB三种颜色信息分别成为三种颜色的通道，所以透明度信息也成为Alpha通道。 矢量图（Vector） 用点、直线或者多边形等基于数学方程的几何图形表示的图像。 位图与矢量图 位图的放大实际上是每个像素的放大，单个像素的放大会使线条和形状参差不齐，导致我们看到的图片“模糊不清晰”。而矢量图通过路径和颜色来记录图片信息，放大之后并不会失真。 位图处理已经标准化，并且硬编码到显卡内，GPU能够处理位图。但矢量图的处理只能依靠CPU。 PNG编码与解码PNG文件结构PNG图像格式文件由文件署名和数据块(chunk)组成。 文件署名域（Signature）一张 PNG 图片二进制数据的开头必须是这 8 字节: 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a 转换为 10 进制是 137, 80, 78, 71, 13, 10, 26, 10。 （Linux下我们可以用file命令直接查看文件的实际格式，但是他本质上也是利用文件头标志来进行文件类型判断的。） 数据块（Chunks）有两种类型的数据块，一种是称为关键数据块(critical chunk)；另一种叫做辅助数据块(ancillary chunks)。 每个数据块都包含图片的描述信息，数据块由四个部分组成： 名称 长度 说明 Length 4 bytes 指定 Chunk Data 的长度 Chunk Type 4 bytes 指定数据块类型 Chunk Data 可变 按照Chunk Type存放指定数据 CRC 4 bytes 检查是否有错误的循环冗余代码 这里要注意 Length 保存的是该数据块中 Chunk Data 的长度，也就是说，一个数据块的长度应该为 Length 的值加上12 bytes。 Chunk Type 由4个字符组成，：第一个字符是否大写（critical），决定了该数据块是否是关键（critical）数据块；第二个字符大写表示公开，小写表示私有；第三个字符规定必须大写；第四个字符大写则表示只能在关键数据块不变时被复制，小写则表示任何情况下能复制。 关键数据块关键数据块定义了4个标准数据块，每个PNG文件都必须包含它们。 1、文件头数据块IHDR(header chunk) 包含有PNG文件中存储的图像数据的基本信息，并要作为第一个数据块出现在PNG数据流中，而且一个PNG数据流中只能有一个文件头数据块。它用13个字节按照顺序来表示图像数据的基本信息： 域的名称 长度 说明 Width 4 bytes 图片宽度，以像素为单位 Height 4 bytes 图片高度，以像素为单位 Bit Depth 1 byte 图像深度 Color Type 1 byte 颜色类型 Compression Method 1 byte 压缩算法 Filter Method 1 byte 滤波方法 Interlace Method 1 byte 扫描方法 Bit Depth代表图像深度。索引彩色图像：1，2，4或8；灰度图像：1，2，4，8或16；真彩色图像：8或16； Color Type（颜色类型）PNG 图片一共有 5 种色彩类型，0 代表灰度颜色，2 代表用 RGB 表示颜色，即 (R, G, B)，3 代表用色板表示颜色，4 代表灰度和透明度来表示颜色，6 代表用 RGB 和透明度表示颜色，即 (R, G, B, A)。色板的色彩类型里，每个像素是由 1 个色彩通道表示的。 Co2,mpression Method 代表了压缩算法。目前只支持 0，表示 deflate&#x2F;inflate。（Deflate&#x2F;inflate 是一种结合了 LZ77 和霍夫曼编码的无损压缩算法，被广泛运用于 7-zip，zlib，gzip 等场景。） Filter Method 代表在压缩前应用的过滤函数类型，目前只支持 0。过滤函数类型 0 里面包括了 5 种过滤函数。 Interlace Method 代表图片数据是否经过交错，0 代表非隔行扫描，1 代表 Adam7。 2、调色板数据块PLTE(palette chunk) 它包含有与索引彩色图像(indexed-color image)相关的彩色变换数据，它仅与索引彩色图像有关，如果存在，要放在图像数据块(image data chunk)之前。真彩色的PNG数据流也可以有调色板数据块，目的是便于非真彩色显示程序用它来量化图像数据，从而显示该图像。结构如下： 颜色 字节 意义 Red 1 byte 0 &#x3D; 黑色, 255 &#x3D; 红 Green 1 byte 0 &#x3D; 黑色, 255 &#x3D; 绿色 Blue 1 byte 0 &#x3D; 黑色, 255 &#x3D; 蓝色 PLTE数据块是定义图像的palette信息，PLTE可以包含1~256个palette信息，每一个palette信息由3个字节组成，因此palette数据块所包含的最大字节数为768，palette的长度应该是3的倍数，否则，这将是一个非法的palette。 对于索引图像，palette信息是必须的，palette的颜色索引从0开始编号，然后是1、2……，palette的颜色数不能超过色深中规定的颜色数（如图像色深为4的时候，调色板中的颜色数不可以超过2^4&#x3D;16），否则，这将导致PNG图像不合法。 3、图像数据块IDAT(image data chunk) 存储实际的图片数据，一个图片数据流可能包含多个连续顺序的 IDAT 数据块。创建 IDAT 数据块的步骤： 将扫描获得的图片信息及其大小储存，具体的图片信息和大小规则在 IHDR 中保存 采取 IHDR 指定的过滤方法，对图像数据进行过滤。目前只有定义了method 0 采取 IHDR 指定的压缩方法，对过滤的数据进行压缩 如果想要读取图片信息，将上面三个步骤逆序执行即可。 4、图像结束数据IEND(image trailer chunk) 它用来标记PNG文件或者数据流已经结束，并且必须要放在文件的尾部。 如果我们仔细观察PNG文件，我们会发现，文件的结尾12个字符看起来总应该是这样的： 00 00 00 00 49 45 4E 44 AE 42 60 82 不难明白，由于数据块结构的定义，IEND数据块的长度总是0（00 00 00 00，除非人为加入信息），数据标识总是IEND（49 45 4E 44），因此，CRC码也总是AE 42 60 82。 表示数据块开始的IHDR必须放在最前面， 表示PNG文件结束的IEND数据块放在最后面，其他数据块的存放顺序没有限制。 辅助数据块（cv查表） 符号 说明 bKGD 指定默认的背景颜色 cHRM 校准色度 dSIG 数字签名 eXIf Exif metadata 信息 gAMA 指定亮度的伽马校准值2, hIST 色彩直方图，估算颜色的使用频率 iCCP ICC color profile iTXt 以键值对方式存储可能的压缩文本和翻译信息 pHYs 指定像素大小或图片比例 sBIT 除了指定位深度（8，16 等等）外，保存原始数据以便恢复 sPLT 提出建议使用的调色板，可能有多个 sRGB 指明是否使用sRGB color space sTER 储存立体视图（stereoscopic）的相关信息， tEXt 保存作者等键值对的文本信息 tIME 上次修改时间 tRNS 保存透明信息，分为不透明、全透明、Alpha zTXt 保存压缩后的文本信息以及对应的压缩方式标识 压缩PNG的压缩分为两个步骤：预解析（过滤）和压缩 隔行扫描隔行扫描（Interlacing），也称交错扫描（interleaving），是一种位图编码的方式，编码时不严格按照相邻行进行。当连接速度比较慢时，采用隔行扫描的图片可以渐进地进行显示，即先显示较为模糊的版本，然后逐渐变清晰。如图： 我们常用的 GIF、PNG、JPEG 都采用了隔行扫描的方式，其中 PNG 采取的是二维、七通道的Adam7，二维表示扫描支持竖直和水平方向，7代表一张图片会被拆分为7个子图片。 和 GIF 采取的一维、四通道算法相比，PNG 在网速相同的情况下，尤其是网速较慢时，能够更快地显示出图片的基本外貌。 Filter（过滤）PNG编码使用差分对原始像素数据进行Filter，该过程无任何压缩损失，并且完全可逆。对图像来说，存储残差所需的比特远远小于实际图像所需，这也是差分编码的收益来源 差分编码 [2,3,4,5,6,7,8]会变成[2,1,1,1,1,1,1]，其中 [2, 3-2&#x3D;1, 4-3&#x3D;1, 5-4&#x3D;1, 6-5&#x3D;1, 7-6&#x3D;1, 8-7&#x3D;1] 如果数据是线性相关的(也就是说，值与前一个值有一些很小的差异)，那么最终会将数据集的值转换为大量重复的小值，这些小值更容易被压缩。 PNG文件格式使用称为“filtering”的delta编码格式。基本上，对于每一个像素扫描线，当前像素都是按照与左边像素、上面像素和上面左侧像素的某种关系进行编码的。 对于不同的内容，须使用不同的Filter类型来提升压缩收益，过滤的重点是将大多数转换后的字节将聚集在零附近，从而为压缩引擎提供更小、更可预测的字节值范围来处理。 为了便于描述，规定了相邻像素相对当前像素的方位：左（A）、上（B）、左上（C）。 C B A X 上文提到的 5 种过滤函数为： 过滤类型 存储值(O)&#x3D;实际值(X)-预测值(R) 0 O &#x3D; X 1 O &#x3D; X - A 2 O &#x3D; X - B 3 O &#x3D; X - (A+B)&#x2F;2 4 Peath(A,B,C) Peath(A,B,C): Paeth预测器(A,B,C的线性函数) Peath具体计算为 1234567891011base = AboveRow[j] + LeftCol[i] – AboveRow[-1]pLeft = Abs(base – LeftCol[i]) // abs(A-C)pTop = Abs(base – AboveRow[j]) // abs(L-C)pTopLeft = Abs(base – AboveRow[-1]) // abs(A+L-2*C)if (pLeft &lt;= pTop &amp;&amp; pLeft &lt;= pTopLeft) pred[i][j] = LeftCol[i] // 使用左边参考像素值else if(pTop &lt;= pTopLeft) pred[i][j] = AboveRow[j] // 使用上方参考像素值else pred[i][j] = AboveRow[-1] // 若上方与左边均判断为不存在边界的情况，则使用左上方的值 选择合适的过滤器？ 没有。每一行进行增量测试压缩，保存最小的结果，然后对下一行重复，对于20行的图像相当于对整个图像进行五次过滤和压缩。对于将被传输和解码多次的图像来说，这可能是一个合理的权衡。 过滤器也很少用于低位深度（灰度）图像，尽管在极少数情况下将此类图像提升到 8 位然后过滤是有效的。但是，一般来说，过滤器类型 None 是最好的。 一些接近最优的经验法则：比如对调色板图像以及低于8位的灰度图像不使用过滤器；对于其他的图像，选择最小化绝对差和的滤波器；不是使用256模除(%)，而是使用标准的带符号数学，然后获取abs值，并将它们全部添加到给定行中，然后比较其他筛选器类型的和，选择给出最小和的过滤器。 Deflate正式的压缩阶段使用 Deflate 进行压缩，它由 Huffman 编码 和 LZ77 压缩构成。Deflate是一种压缩数据流的算法，任何需要流式压缩的地方都可以用（但我并没有去了解它具体的实现，所以就略过吧） 解码（图片和数据均来自一步一步解码 PNG 图片） 👆 这是一张我们接下去要解码的图片，但它太小了，放大了展示给大家看下。👇 二进制数据如下 0 ~ 3 4 ~ 7 8 ~ 11 12 ~ 15 0 ~ 15 137, 80, 78, 71 13, 10, 26, 10 0, 0, 0, 13 73, 72, 68, 82 16 ~ 31 0, 0, 0, 2 0, 0, 0, 2 2, 3, 0, 0 0, 15, 216, 229 32 ~ 47 183, 0, 0, 0 1, 115, 82, 71 66, 1, 217, 201 44, 127, 0, 0 48 ~ 63 0, 9, 112, 72 89, 115, 0, 0 11, 19, 0, 0 11, 19, 1, 0 64 ~ 79 154, 156, 24, 0 0, 0, 12, 80 76, 84, 69, 255 0, 0, 0, 255 80 ~ 95 0, 0, 0, 255 255, 255, 255, 251 0, 96, 246, 0 0, 0, 4, 116 96 ~ 111 82, 78, 83, 255 255, 255, 127, 128 144, 197, 89, 0 0, 0, 12, 73 112 ~ 127 68, 65, 84, 120 156, 99, 16, 96 216, 0, 0, 0 228, 0, 193, 39 128 ~ 143 168, 232, 87, 0 0, 0, 0, 73 69, 78, 68, 174 66, 96, 130 每个表格的单元格内有 4 字节数据，每个字节由 8 位组成，1 位代表的是 0 或者 1 的一个数字。 签名部分 0 ~ 3 4 ~ 7 137, 80, 78, 71 13, 10, 26, 10 0x89, 0x50, 0x4e, 0x47 0x0d, 0x0a, 0x1a, 0x0a 这张图片的前 8 个字节满足PNG签名的要求。 文件头数据块部分 8 ~ 11 12 ~ 15 0, 0, 0, 13 73, 72, 68, 82 长度 类型 13 IHDR 16 ~ 19 20 ~ 23 24 ~ 27 28 0, 0, 0, 2 0, 0, 0, 2 2, 3, 0, 0 0 width height depth, colorType, compression, filter interlace 2 2 2, 3, 0, 0 0 29 ~ 32 15, 216, 229, 183 CRC32 校验和 PLTE部分 75 ~ 78 79 ~ 82 83 ~ 86 255, 0, 0, 0 255, 0, 0, 0 255, 255, 255, 255 色板中包含的数据是 RGB 数据，以 R, G, B 的形式保存，这里一共 12 字节，表示了 4 个色块。得到的色板信息如下： 色板 1[[255, 0, 0], [0, 255, 0], [0, 0, 255], [255, 255, 255]] tRNS部分 99 ~ 102 255, 255, 255, 127 这个数据块为色板提供透明信息，每个字节表示一个色块的透明信息。与色板组合后的色板如下： 色板 1[[255, 0, 0, 255], [0, 255, 0, 255], [0, 0, 255, 255], [255, 255, 255, 127]] IDAT部分 我们重点关注图像数据块的解码部分。 107 ~ 110 111 ~ 114 0, 0, 0, 12 73, 68, 65, 84 长度 类型 12 IDAT 声明 12 字节的 IDAT像素数据 115 ~ 118 119 ~ 122 123 ~ 126 120, 156, 99, 16 96, 216, 0, 0 0, 228, 0, 193 所有行的像素数据会经过 deflate 压缩算法压缩。所以，需要对这里的像素数据解压，这里直接使用了 zlib.inflate() 函数。 解压出来的像素数据是 Uint8Array：0, 16, 0, 176。 扫描线 Scanline 一根扫描线包含图片一行像素的数据。我们知道这张图片的高度是 2，也就是像素数据中有 2 行扫描线。 一根扫描线由 1 字节的过滤函数标记和像素信息组成。像素信息一个接一个地排列，中间没有多余的空位。如果扫描线长度不足以填满字节的位数，最后几位会被补齐。一根扫描线的结构如下： 过滤函数 像素…[补齐…] 8 位 每像素位数 * 每行像素数 + 补齐 色彩类型 - 色彩通道 - 通道深度 - 每像素位数 色彩类型 色彩 每像素通道数 通道深度 每像素位数 0 灰度 1 1, 2, 4, 8, 16 1, 2, 4, 8, 16 2 真彩色（RGB） 3 8, 16 24, 48 3 色板 1 1, 2, 4, 8 1, 2, 4, 8 4 灰度和透明度 2 8, 16 16, 32 6 色彩色和透明度（RGBA） 4 8, 16 32, 64 这张图片的色彩类型是 3，所以每个像素包含 1 个色彩通道。又因为图片的通道深度是 2，所以我们知道每个像素是用 2 位来表示的。 解码扫描线 行 过滤函数 像素…[补齐…] 8 位 每像素 2 位 * 2 像素 + 4 位补齐 &#x3D; 8 位 0 0 00010000 (16) 1 0 10110000 (176) 这张图片里面的过滤函数 0 表示这张图数据未经过滤。所以我们只要保留原始数据就行了。 扫描线像素 行 第 1 列 第 2 列 补齐… 0 00 01 0000 1 10 11 0000 这里每个像素中的数据表示了这个像素的颜色在色板中的索引。根据色板，我们可以还原出图片的像素信息：[[255, 0, 0, 255], [0, 255, 0, 255], [0, 0, 255, 255], [255, 255, 255, 127]]。 图片像素 行\\列 0 1 0 (255, 0, 0, 255) (0, 255, 0, 255) 1 (0, 0, 255, 255) (255, 255, 255, 127) 最后可以得到这样一个PNG图片信息： 12345imageData = &#123; width: 2, height: 2, data: [255, 0, 0, 255, 0, 255, 0, 255, 0, 0, 255, 255, 255, 255, 255, 127],&#125;; 参考PNG (Portable Network Graphics) Specification http://www.libpng.org/pub/png/spec/1.2/PNG-Contents.html PNG文件格式 https://rimson.top/png-format/ PNG文件格式详解 https://blog.mythsman.com/post/5d2d62b4a2005d74040ef7eb/ Portable Network Graphics (PNG) Specification (Second Edition) https://www.w3.org/TR/PNG/ 一步一步解码 PNG 图片 https://vivaxyblog.github.io/2019/12/07/decode-a-png-image-with-javascript-cn.html","categories":[{"name":"未分类","slug":"未分类","permalink":"https://blog.ryaoknw.site/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[]},{"title":"Ubuntu依赖错误记录(未解决)","slug":"Ubuntu依赖错误记录-未解决","date":"2022-03-12T17:20:21.000Z","updated":"2022-09-21T12:55:02.882Z","comments":true,"path":"2022/3/5008382d91a6/","link":"","permalink":"https://blog.ryaoknw.site/2022/3/5008382d91a6/","excerpt":"","text":"Ubuntu依赖错误记录(未解决)前言在使用如apt update apt upgrade apt install等等依赖操作时偶尔出现的错误，一直没有找到通用的解决方案，且dependencies的错误种类各样，故在此仅仅记录解决的操作 记录The following packages have unmet dependencies: 下列软件包有未满足的依赖关系： libpython2-stdlib : 破坏: libpython-stdlib (&lt; 2.7.15-2) 但是 2.7.5-5ubuntu3 正要被安装 python2 : 破坏: python (&lt; 2.7.15-2) 但是 2.7.5-5ubuntu3 正要被安装 python2-minimal : 破坏: python-minimal (&lt; 2.7.15-2) 但是 2.7.5-5ubuntu3 正要被安装 经常出现的问题，原因是尝试安装的软件包正在寻找它在当前版本中找不到的“依赖关系”。一般在换源后会出现这样的问题。在网上的通用方法是更新包数据库，清除包缓存，然后下载并重新安装较新版本。 1234sudo apt-get autocleansudo apt-get -f installsudo dpkg --configure -asudo apt-get -f install 修复错误可以使用 1234sudo apt-get updatesudo apt-get -u dist-upgradesudo apt-get -o Debug::pkgProblemResolver=yes dist-upgradesudo apt-get remove --dry-run package-name 或者 1234sudo apt-get updatesudo apt-get -u dist-upgradesudo apt-get clean package-namesudo apt-get install --reinstall package-name 当然由于未知原因，有时这些操作并不管用。我一般直接采用 uninstall所有的报错包，在检查软件源都可用后将它们重新安装下来。 dpkg: error processing archive &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F;* 准备解压 …&#x2F;libopenal1_1%3a1.19.1-1_i386.deb …正在解压 libopenal1:i386 (1:1.19.1-1) 并覆盖 (1:1.19.1-1) …dpkg: 处理归档 &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F;libopenal1_1%3a1.19.1-1_i386.deb (–unpack)时出错： 尝试覆盖共享的 ‘&#x2F;usr&#x2F;share&#x2F;doc&#x2F;libopenal1&#x2F;changelog.Debian.gz’, 它与软件包 libopenal1:i386 中的其他实例不同在处理时有错误发生： &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F;libopenal1_1%3a1.19.1-1_amd64.deb &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F;libopenal1_1%3a1.19.1-1_i386.debE: Sub-process &#x2F;usr&#x2F;bin&#x2F;dpkg returned an error code (1) 出现的原因可能是未完全安装。 可以用以下命令强行overwrite 1sudo dpkg -i --force-overwrite /var/cache/apt/archives/libopenal1_1%3a1.19.1-1_amd64.deb .deb尤其多的时候为了不麻烦其实采用全部overwrite目前也没有出现过问题 1sudo dpkg -i --force-overwrite /var/cache/apt/archives/*.deb","categories":[{"name":"未分类","slug":"未分类","permalink":"https://blog.ryaoknw.site/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[]},{"title":"Linux下设定键盘Fn键控制功能","slug":"Linux下设定键盘Fn键控制功能","date":"2022-03-01T07:29:04.000Z","updated":"2022-09-21T12:55:02.882Z","comments":true,"path":"2022/3/80bb26f6b2bf/","link":"","permalink":"https://blog.ryaoknw.site/2022/3/80bb26f6b2bf/","excerpt":"","text":"Linux下设定键盘Fn键控制功能前言入手新键盘，在Linux上使用时发现顶部F1-F12区域默认为功能键，应该是Mac的键盘行为。我希望在使用Fn+FXX来使用这些功能。 设定方法可以通过设定 /sys/module/hid_apple/parameters/fnmode来控制Fn的模式 0 禁用功能键，按Fn+FXX等同于触发FXX 1 默认功能键，按FXX等同于触发Fn+FXX 2 默认非功能键，按FXX触发FXX，按Fn+FXX触发Fn+FXX。这也是windows下的默认行为 于是echo 2 &gt; /sys/module/hid_apple/parameters/fnmode即可 要让该设定永久生效，需要写入启动项 12#sudo vim /path/hid_apple.confoptions hid_apple fnmode=2 12#软链接sudo ln -s /path/hid_apple.conf /etc/modprobe.d/hid_apple.conf 自组键盘经历之前的黑皮cherry红轴108键的键盘实在是不好用，想要换一个87键的键盘。但是一直没有找到好用且好看的键盘。了解到客制化键盘的说法，简单看了一下感觉不太复杂，简单来说就是套件+键轴+键帽，于是动手组了一把。 套件用的腹灵MK870，热插拔+RGB+三模确实很香，而且还有三侧出线。值得一提的是大键调教的很好，空格键处还贴心地配了两边的黑条。不过买回来没有送typec连接线，得自己拿一根。无线模式延迟还是有的，高速打字的时候能明显感觉得到，不建议用无线来打游戏 键轴直接用的87个G白pro，很舒服的线段轴。（在寝室用也比较优雅，不会被刀）。插轴的时候，轴脚买回来歪了要掰直再插。 键帽随便买一套好看的就好，只要是PBT的材质。二色工艺的可以透光，不过其实无所谓","categories":[{"name":"未分类","slug":"未分类","permalink":"https://blog.ryaoknw.site/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[]},{"title":"<萌化>Ubuntu设置启用“嗨多磨!”登录音效","slug":"[萌化]Ubuntu设置启用`嗨多磨!`登录音效","date":"2021-12-08T08:11:56.000Z","updated":"2022-09-21T12:55:02.882Z","comments":true,"path":"2021/12/2d290da6e095/","link":"","permalink":"https://blog.ryaoknw.site/2021/12/2d290da6e095/","excerpt":"","text":"[萌化]Ubuntu设置启用“嗨多磨！”登录音效前言 はいどうもー！ バーチャルYouTuber【キズナアイ】です！ HAI DOMO！VIRTUAL YOUTUBER KIZUNA AI DESU！ 2021年12月4日，在仅仅5年后的纪念直播上，“虚拟偶像”绊爱亲自宣布了“休眠”的消息。 （没错，这其实是套着折腾教学的情怀感想回，先咕咕咕）","categories":[{"name":"未分类","slug":"未分类","permalink":"https://blog.ryaoknw.site/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[]},{"title":"MapReduce论文学习","slug":"MapReduce论文学习","date":"2021-11-23T02:29:59.000Z","updated":"2022-09-21T12:55:02.882Z","comments":true,"path":"2021/11/df9fd59361b6/","link":"","permalink":"https://blog.ryaoknw.site/2021/11/df9fd59361b6/","excerpt":"","text":"MapReduceMapReduce是什么Google三驾马车 Google的基础设施有三驾马车，分别是《Google File System》、《Google MapReduce》以及《Google BigTable》 现代各种优秀的分布式系统实现的本质，都源于那几篇经典的研究和论文。比如非常流行的 Hadoop(HDFS、MapReduce、Hbase)、Spark、Hive，以及国产数据库软件 TiDB、OceanBase 都是参考这几篇经典论文设计的 三驾马车之间的关系： MapReduce解决的问题谷歌在这为了处理海量的原始数据，已经实现了数以百计的、专用的计算方法。这些计算方法用来处理大量的原始数据。 2004年谷歌提出了MapReduce, 在此之前谷歌程序员面对的大规模数据集,常常需要编程实现: 统计某个关键词的现的频率,计算PageRank 对大规模数据按词频排序 对多台机器上的文件进行Grep等 这些工作不可能在一台机器上完成(否则也不能称之为大规模)，要想在可接受的时间内完成运算，只有将这些计算分布在成百上千的主机上,因此谷歌的程序员每次编写代码都需要处理并行计算,分发数据,处理错误等问题。 为了解决上述复杂的问题，谷歌设计了一个新的抽象模型，使用这个抽象模型，我们只要表述我们想要执行的简单运算即可，而不必关心并行计算、容错、数据分布、负载均衡等复杂的细节，这些问题都被封装在了一个库里面。 设计这个抽象模型的灵感来自Lisp和许多其他函数式语言的Map和Reduce的原语，在大多数运算都包含这样的操作： 在输入数据的“逻辑”记录上应用Map操作得出一个中间key&#x2F;value pair集合，然后在所有具有相同key值的value值上应用Reduce操作，从而达到合并中间的数据，得到一个想要的结果的目的。 使用MapReduce模型，再结合用户实现的Map和Reduce函数，我们就可以非常容易的实现大规模并行化计算；通过MapReduce模型自带的“再次执行”（re-execution）功能，也提供了初级的容错实现方案 MapReduce的架构&#x2F;实现MapReduce编程模型例子：WordCount 利用一个输入的key&#x2F;value pair集合来产生一个输出的key&#x2F;value pair集合。 MapReduce库的用户用两个函数表达这个计算：Map和Reduce。 用户自定义的Map函数接受一个输入的key&#x2F;value pair集合，然后产生一个中间key&#x2F;value pair值的集合。MapReduce库把所有具有相同中间key值I的中间value值集合在一起后传递给Reduce函数。 用户自定义的Reduce函数接受一个中间key的值I和相关的一个value值的集合。Reduce函数合并这些value值，形成一个较小的value值的集合。通常我们通过一个迭代器把中间value值提供给Reduce函数，这样我们就可以处理无法全部放入内存中的大量的value值的集合。 需要一提的是：每个Map在结束后，会将输出结果产生为一个中间文件 12345678910111213map(String key, String value): // key: document name // value: document contents for each word w in value: EmitIntermediate(w, &quot;I&quot;);reduce(String key, Iterator values): // key: a word // values: a list of counts int result = 0; for each v in values: result += ParseInt(v); Emit(AsString(result)); 用户提供的 Map 函数和 Reduce 函数应有如下类型： 值得注意的是，在实际的实现中 MapReduce 框架使用 Iterator 来代表作为输入的集合，主要是为了避免集合过大，无法被完整地放入到内存中 MapReduce的应用分布式的Grep：Map函数输出匹配某个pattern的一行，Reduce函数是一个恒等函数，即把中间数据复制到输出。 计算URL访问频率：Map函数处理日志中web页面请求的记录，然后输出(URL,1)。Reduce函数把相同URL的value值都累加起来，产生(URL,记录总数)结果。 倒排索引：Map函数分析每个文档输出一个(word,document_id)的列表，Reduce函数的Input是一个word的所有(word，document_id)，排序所有的document_id，输出(word,list(document_id))。所有的输出集合形成一个简单的倒排索引，它以一种简单的算法跟踪词在文档中的位置。 MapReduce架构 用户程序首先调用 MapReduce 库将输入文件分成M个数据片段，每个数据片段的大小一般从16MB到64MB(可以通过可选的参数来控制每个数据片段的大小)。然后用户程序在机群中创建大量的程序副本。 这些程序副本中的有一个特殊的程序：master。副本中其它的程序都是worker程序，由master分配任务。有M个Map任务和R个Reduce任务将被分配，master将一个Map任务或Reduce任务分配给一个空闲的worker。每个worker一项任务 被分配了Map任务的worker程序读取相关的输入数据片段，从输入的数据片段中解析出key&#x2F;value pair，然后把key&#x2F;value pair传递给用户自定义的Map函数，由Map函数生成并输出的中间key&#x2F;value pair，并缓存在内存中。 缓存中的key&#x2F;value pair通过分区函数分成R个区域，之后周期性的写入到本地磁盘上。缓存的key&#x2F;value pair在本地磁盘上的存储位置将被回传给master，由master负责把这些存储位置再传送给Reduce worker。 当Reduce worker程序接收到master程序发来的数据存储位置信息后，使用RPC(Remote Procedure Call：该协议允许运行于一台计算机的程序调用另一个地址空间(通常为一个开放网络的一台计算机)的子程序)从Map worker所在主机的磁盘上读取这些缓存数据。 当Reduce worker读取了所有的中间数据后，通过对key进行排序后使得具有相同key值的数据聚合在一起。由于许多不同的key值会映射到相同的Reduce任务上，因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。 Reduce worker程序遍历排序后的数据，对于每一个唯一的key值，Reduce worker程序将这个key值和它相关的value值的集合传递给用户自定义的Reduce函数。Reduce函数的输出被追加到所属分区的输出文件。 当所有的Map和Reduce任务都完成之后，master唤醒用户程序。此时，用户程序中的MapReduce调用返回到用户代码中。 在这个过程中： master应当维护多种数据结构。它会存储每个map和reduce任务的状态（空闲、处理中、完成），和每台工作机器的ID（对应非空闲的任务）。 master是将map任务产生的中间文件的位置传递给reduce任务的通道。因此，master要存储每个已完成的map任务产生的R个中间文件的位置和大小。map任务完成时，master会接收到位置和大小的更新信息。这些信息会被逐步发送到正在处理中的reduce任务节点处。 MapReduce的容错因为MapReduce库的设计初衷是使用由成百上千的机器组成的集群来处理超大规模的数据，所以，这个库必须要能很好的处理机器故障。 worker故障如何检测worker的故障？发心跳包。 master周期性的ping每个worker。如果在一定时间范围内没有收到worker返回的信息，master将把这个worker标记为失效。 所有由这个失效的worker完成的Map任务被重设为初始的空闲状态，之后这些任务就可以被安排给其他的worker。同样的，worker失效时正在运行的Map或Reduce任务也将被重新置为空闲状态，等待重新调度。 值得一提的是：worker完成的Reduce任务的输出存储在全局文件系统上，因此不需要再次执行。而Map任务的输出存储在worker对应的这台机器上，不可访问。 当一个Map任务首先被worker A执行，之后由于worker A失效了又被调度到worker B执行，这个“重新执行”的动作会被通知给所有执行Reduce任务的worker。任何还没有从worker A读取数据的Reduce任务将从worker B读取数据 通过这样的方式，MapReduce可以处理大规模worker失效的情况。 master故障那就寄！ 备份。一个解决办法是让master周期性将其维护的数据写入磁盘，作为checkpoint，当master挂了后可以通过checkpoint来重启master进程。 但需要考虑到master故障后再恢复比较麻烦，只有一个master进程，Google的实现是当master故障后，让客户检查到这个状态，然后中止运算并重启MapReduce操作。 MapReduce在实践过程中的优化存储位置在分布式系统中，网络带宽通常是稀缺资源，很容易成为系统瓶颈。为了减少网络通信，Google通过将输入数据存储在本地磁盘上。 GFS把每个文件按64MB一个Block分隔，每个Block保存在多台机器上，环境中就存放了多份拷贝(一般是3个拷贝)。MapReduce的master在调度Map任务时会考虑输入文件的位置信息，尽量将一个Map任务调度在包含相关输入数据拷贝的机器上执行 如果无法实现，就尝试在保存有输入数据拷贝的机器附近的机器上执行Map任务（比如在同一个交换机的机器上执行Map） 任务粒度正常情况下M、R比集群中的worker数量大很多，这样一来在每台worker机器都执行大量的不同任务能够提高集群的负载均衡能力 但实际情况下，master会执行O(M+R)次调度，并且在内存中保存O(M*R)个状态 R的值是由用户指定的，而M的值也尽量满足每一个独立任务都是处理大约16M到64M的输入数据，使得上述存储位置的优化最有效 比如M&#x3D;200000, R&#x3D;5000，使用2000个worker 备用任务在运算过程中，如果有几台机器运行特别慢，会极大影响MapReduce操作的总时间。 这里有个通用的方法。MapReduce会启用处理中状态(in-progress)的任务的备用任务进程，它和原任务做相同的事情，无论哪个完成了任务，都视为该任务已经完成 分区函数前面说到R的值是由用户指定的，可以通过分区函数对数据分区，比如用hash(key) mod R进行分区，能够让key&#x2F;value pair比较均衡的分给执行Reduce的worker。当输出的key值是URLs，我们希望每个主机的所有条目保持在同一个输出文件中，又可以通过hash(hostname(urlkey)) mod R将所有来自同一个主机的URLs分在一个分区中。 顺序保证我们确保在给定的分区中，中间key&#x2F;value pair数据的处理顺序是按照key值增量顺序处理的。这样的顺序保证对每个分区生成一个有序的输出文件，这对于需要对输出文件按key值随机存取的应用非常有意义。 合并函数比如在进行词频统计时，一些词的出现频率非常的高，这会导致产生例如(I,1)这种key&#x2F;value pair，导致中间文件到同一个Reduce的大小不均衡。 此时可以通过指定一个可选的combiner函数，combiner函数首先在本地将这些记录进行一次合并，然后将合并的结果再通过网络发送出去。","categories":[{"name":"未分类","slug":"未分类","permalink":"https://blog.ryaoknw.site/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[]},{"title":"磁盘挂载没有写权限？彻底关闭你的windows快速启动","slug":"彻底关闭你的windows","date":"2021-09-21T21:30:00.000Z","updated":"2022-09-21T12:55:02.882Z","comments":true,"path":"2021/9/7a37f059971a/","link":"","permalink":"https://blog.ryaoknw.site/2021/9/7a37f059971a/","excerpt":"","text":"win10的快速启动我们都知道windows10在“电源管理”处有一个“快速启动”选项，默认情况下他是开启的。 这会让windows10更快的关闭和启动。在启用该选项时，本质上win10让你的PC执行了部分休眠，事实上，你的windows并没有关机。（即使你长按电源键关机或者手动点击关机） 快速启动导致的问题在双系统下，如果你在某个linux系统上尝试挂载window磁盘，便会出现磁盘只有读权限，而没有写权限。 尝试umount后重新挂载依然无法获得写权限。 我早就关闭了“快速启动”选项，但在某一天开始依旧出现了这样的问题，显然我需要一个彻底关闭windows的方法。 解决方法搜索how to shutdown windows fully彻底关机有两种： 1、点击关机时按住shirt键 2、使用 shutdown /s /f /t 0进行关机 全部尝试后依然无效。 了解到，在关闭快速启动选项之前，休眠文件会由windows创建，你可以在系统磁盘中找到 hiberfil.sys的文件。 然而在GUI中关闭快速启动选项后，文件并不会由windows删除。（windows为啥设计这种脏操作） 解决： 1、在确保有hiberfil.sys文件存在 2、打开管理员权限的命令行，执行powercfg /h off 3、确保hiberfil.sys文件已经删除，再重新启动即可。 参考https://unix.stackexchange.com/questions/107978/cant-access-windows-drive-windows-is-hibernated-refused-to-mount https://superuser.com/questions/1010084/windows-is-hibernated-refused-to-mount-but-fast-startup-is-disabled-on-window https://unix.stackexchange.com/questions/432869/cant-mount-dual-boot-partition-windows-is-hibernated","categories":[{"name":"未分类","slug":"未分类","permalink":"https://blog.ryaoknw.site/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[]},{"title":"敏感词过滤实现","slug":"敏感词过滤实现","date":"2021-07-21T11:23:13.000Z","updated":"2022-09-21T12:55:02.882Z","comments":true,"path":"2021/7/ac22932d46a9/","link":"","permalink":"https://blog.ryaoknw.site/2021/7/ac22932d46a9/","excerpt":"","text":"前言需要实现一个基于已有的敏感词库的敏感词过滤的功能 实现方案遍历匹配遍历词库的每一个词，匹配后进行过滤（比如把它们全部换成*号） 字符串匹配比较常见的算法有： Brute Force算法 KMP算法 Boyer-Moore算法（BM算法） 当然，用于字符串匹配的算法有非常多，这里不再赘述 一个敏感词库的词量往往是巨大的，它会远大于需要处理的文本量，在这种场景下使用遍历匹配的方法显然不可行 利用 DFA 算法DFA：Deterministic Finite Automata （确定型有穷自动机）从一个状态通过一系列的事件转换到另一个状态，即 state -&gt; event -&gt; state。 确定：状态以及引起状态转换的事件都是可确定的，不存在“意外”。 有穷：状态以及事件的数量都是可穷举的。 计算机操作系统中的进程状态与切换可以作为 DFA 算法的一种近似理解 举例：将DFA算法用于匹配关键词 我们可以将每个文本片段作为状态，例如“匹配关键词”可拆分为“匹”、“匹配”、“ 匹配关”、“匹配关键”和“匹配关键词”五个文本片段。 过程： 初始状态为空，当触发事件“匹”时转换到状态“匹”； 触发事件“配”，转换到状态“匹配”； 依次类推，直到转换为最后一个状态“匹配关键词”。 再让我们考虑多个关键词的情况，例如“匹配算法”、“匹)配关键词”以及“信息抽取”。 我们可以发现对于关键词匹配，它的状态是一个树形结构，这样我们判断一个词是否为敏感词时就大大减少了检索的匹配范围。 如何构建图示结构？ 为了处理整个关键词库，我们可以使用字典（数组、哈希表、balabala…..） 字典使用 HashTable 实现，因为一个节点的子节点个数未知，而 HashTable 可以动态扩展，而且可以在 O(1) 的时间复杂度内判断某个子节点是否存在 1234567891011121314151617181920212223242526272829303132333435state_event_dict = &#123; &quot;匹&quot;: &#123; &quot;配&quot;: &#123; &quot;算&quot;: &#123; &quot;法&quot;: &#123; &quot;is_end&quot;: True &#125;, &quot;is_end&quot;: False &#125;, &quot;关&quot;: &#123; &quot;键&quot;: &#123; &quot;词&quot;: &#123; &quot;is_end&quot;: True &#125;, &quot;is_end&quot;: False &#125;, &quot;is_end&quot;: False &#125;, &quot;is_end&quot;: False &#125;, &quot;is_end&quot;: False &#125;, &quot;信&quot;: &#123; &quot;息&quot;: &#123; &quot;抽&quot;: &#123; &quot;取&quot;: &#123; &quot;is_end&quot;: True &#125;, &quot;is_end&quot;: False &#125;, &quot;is_end&quot;: False &#125;, &quot;is_end&quot;: False &#125;&#125; 用嵌套字典来作为树形结构（这玩意就是Trie 树），key 作为事件，通过is_end字段来判断状态是否为最后一个状态，如果是最后一个状态，则停止状态转换，获取匹配的关键词。 每一个敏感词都可以看做一个关键词，构建敏感词的时间复杂度是可以忽略不计的，因为构建完成后我们是可以无数次使用的。对于查找敏感词的时间复杂度。如果字符串的长度为 n，而每个敏感词查找的时间复杂度是 O(m)（m 为最长的字符串的长度），我们需要对字符串遍历 n遍，所以查找敏感词的这个过程的时间复杂度为 O(m*n)。用DFA算法能够很好的满足需求。 缺点：占用的内存和敏感词库的大小成正比。 为什么不使用正则匹配正则表达式引擎有两种：NFA和DFA。我们常常说用正则去匹配文本，这是NFA的思路。 大多数正则表达式引擎本质是NFA（非确定性有穷自动机）。而NFA由于在匹配时会多次回溯，导致相比于DFA效率低了很多 为什么正则使用NFA？： NFA：Nondeterministic Final Auomaton（非确定型有穷自动机） 对于正则匹配，同样逐个读入待匹配字符，每读一个字符，即选取多种可能的匹配规则的一种继续匹配，一旦发现匹配失败，则回溯（backtrack）到之前的状态，重新开始尝试新的一种匹配，直至匹配完成 NFA vs DFA 正则表达式在计算机看来只是一串符号，正则引擎首先肯定要解析它。NFA引擎只需要编译就好了；而DFA引擎则比较繁琐，编译完还不算，还要遍历出表达式中所有的可能。因为对DFA引擎来说机会只有一次，它必须得提前知道所有的可能，才能匹配出最优的结果 DFA的时间复杂度是线性的。DFA不记录所有可能的路径，结果是确定的。 NFA的时间复杂度较不稳定，好坏程度取决于正则表达式的书写与匹配对象的复杂程度。但NFA相较于DFA，它具有更强大的功能。因此，它也成为Java，JavaScript，PHP，Python，Ruby实现正则表达式的方式。NFA匹配结果，基于表达式，它记录所有可能的路径 正则中的非贪婪模式、反向引用、零宽断言等只有使用NFA引擎才有。因此大部分正则引擎都使用NFA来实现 参考DFA 算法 敏感词过滤、脱敏 Regex 正则表达式原理及如何从零实现 java 实现敏感词过滤","categories":[{"name":"未分类","slug":"未分类","permalink":"https://blog.ryaoknw.site/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"敏感词过滤","slug":"敏感词过滤","permalink":"https://blog.ryaoknw.site/tags/%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4/"},{"name":"DFA","slug":"DFA","permalink":"https://blog.ryaoknw.site/tags/DFA/"}]},{"title":"CUDA+cuDNN+pytorch GPU环境搭建","slug":"CUDA-cuDNN-pytorch-GPU环境搭建","date":"2021-05-19T08:55:56.000Z","updated":"2022-09-21T12:55:02.882Z","comments":true,"path":"2021/5/8432c972721a/","link":"","permalink":"https://blog.ryaoknw.site/2021/5/8432c972721a/","excerpt":"","text":"安装CUDA 安装 首先去英伟达官网下载cuda安装包：https://developer.nvidia.com/cuda-toolkit-archive 踩坑：这里最好不要使用deb的安装，推荐使用runfile 我最初在使用deb的安装时，在最后一步 1sudo apt-get -y install cuda 中，得到了depends: cuda-11-3 (&gt;= 11.3.0) but it is not going to be installed site:forums.developer.nvidia.com的错误，而这个错误并没有得到良好的解决方案。 我在搜索资料后推测是由于本身已经安装了nvidia-driver所导致的结果，而英伟达的cuda本身已经自带了驱动（这是一件很奇怪的事情）。 因此我推荐runfile的安装，我在此安装成功。 12wget &lt;https://developer.download.nvidia.com/compute/cuda/11.3.0/local_installers/cuda_11.3.0_465.19.01_linux.run&gt;sudo sh cuda_11.3.0_465.19.01_linux.run 需要注意的是，在执行sudo sh cuda_11.3.0_465.19.01_linux.run时，最好使用sudo sh cuda_11.3.0_465.19.01_linux.run -no-opengl-libs cuda主要有以下参数： -no-opengl-libs：表示只安装驱动文件，不安装OpenGL文件。必需参数，原因同上。注意：不是no-opengl-files。 -uninstall (deprecated)：用于卸载CUDA Driver（已废弃）。 -toolkit：表示只安装CUDA Toolkit，不安装Driver和Samples -help：查看更多高级选项。 安装过程中的坑 首先会有一个阅读声明，一直滑到底部输入accept即可。我遇到了无法滑到底部的情况，也就是不能输入accpet。 解决： 使用init 3关闭图形界面即可。 选项 选项install nvidia accelerated Graphics Driver,输入n，因为我们已经安装了nvidia的驱动。 选项install the OpenGL libraries,如果双显卡(集显+独显)选择n，如果只有独显可以选择y，如果双显卡选择y的话，会出现黑屏或者循环登录的问题，如果加了上面的参数就不会出现这个选项了。 后面的可以都选择yes，最后一个选项我们可以选择n,也就是不复制Samples，因为安装目录下有samples。 之后install等待安装结束即可 此时使用startx重新进入图形界面。 配置环境 终端编辑/etc/profile或者.bashrc 123export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-11.3/lib64export PATH=$PATH:/usr/local/cuda-11.3/binexport CUDA_HOME=$CUDA_HOME:/usr/local/cuda-11.3 运行source /etc/profile或者source .bashrc 安装cuDNNInstalling from a Tar File 1.Navigate to your directory containing the cuDNN Tar file. 2.Unzip the cuDNN package. 1tar -xzvf cudnn-9.0-linux-x64-v7.tgz 3.Copy the following files into the CUDA Toolkit directory, and change the filepermissions. 123sudo cp cuda/include/cudnn*.h /usr/local/cuda/include #此处我和官方文档不同sudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64sudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn* 使用cat /usr/local/cuda/include/cudnn_version.h | grep CUDNN_MAJOR -A 2可以查看版本 网上的cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2这个操作显然在官方文档的操作下是不行的。 安装pytorchconda使用一个正确的环境，不然会默认安装在base上 在 https://pytorch.org/get-started/locally/ 选择正确的方案即可，如： 1conda install pytorch torchvision torchaudio cudatoolkit=11.1 -c pytorch -c nvidia","categories":[{"name":"linux","slug":"linux","permalink":"https://blog.ryaoknw.site/categories/linux/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://blog.ryaoknw.site/tags/%E6%95%99%E7%A8%8B/"},{"name":"linux","slug":"linux","permalink":"https://blog.ryaoknw.site/tags/linux/"}]},{"title":"解决ubuntu deepin-wine TIM无法打开文件位置","slug":"解决ubuntu-deepin-wine-TIM无法打开文件位置","date":"2021-04-21T05:26:02.000Z","updated":"2022-09-21T12:55:02.882Z","comments":true,"path":"2021/4/ca7d14eb3e01/","link":"","permalink":"https://blog.ryaoknw.site/2021/4/ca7d14eb3e01/","excerpt":"","text":"这个坑其实比较好理解 打开文件位置,其实是两个步骤: 打开资源管理器–&gt;跳转到指定位置 deepin-tim是在deepin系统上的, deepin的资源管理器是dde-file-manager ubuntu上面可没有这玩意, 所以打不开很正常 所以添加可执行文件dde-file-manager间接打开ubuntu的资源管理器就可以了 在&#x2F;usr&#x2F;bin&#x2F; 下面创建文件 dde-file-manager 1sudo vim /usr/bin/dde-file-manager 输入以下命令 1234#!/usr/bin/python3import sysimport osos.system(&#x27;nautilus &quot;&#x27;+sys.argv[2]+&#x27;&quot;&#x27;) nautilus 是ubuntu的资源管理器 对该文件授权 1sudo chmod +x /usr/bin/dde-file-manager","categories":[{"name":"linux","slug":"linux","permalink":"https://blog.ryaoknw.site/categories/linux/"},{"name":"折腾","slug":"折腾","permalink":"https://blog.ryaoknw.site/categories/%E6%8A%98%E8%85%BE/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://blog.ryaoknw.site/tags/ubuntu/"},{"name":"wine","slug":"wine","permalink":"https://blog.ryaoknw.site/tags/wine/"}]},{"title":"解决jetbrains IDE(Goland)莫名报错: Unresolved reference","slug":"解决jetbrains-IDE莫名报错-Unresolved-reference","date":"2021-04-15T04:28:42.000Z","updated":"2022-09-21T12:55:02.882Z","comments":true,"path":"2021/4/ed34e8e9b6f3/","link":"","permalink":"https://blog.ryaoknw.site/2021/4/ed34e8e9b6f3/","excerpt":"","text":"前言一觉醒来项目直接爆红，很怪很怪，go mod是没有问题的 struct全部unresolved reference的错误，但是程序却可以正常运行 解决目前有两种解决方案，这对于jetbrains家的所有IDE都是可行的 方案一在settings - go - gopath下方勾上 “Index entire gopath” 方案二在file - invalidate caches中选择invalidate and restart","categories":[{"name":"报错","slug":"报错","permalink":"https://blog.ryaoknw.site/categories/%E6%8A%A5%E9%94%99/"}],"tags":[{"name":"jetbrains","slug":"jetbrains","permalink":"https://blog.ryaoknw.site/tags/jetbrains/"}]},{"title":"解决Ubuntu连接华为freebuds3蓝牙耳机失败","slug":"解决Ubuntu连接华为freebuds3蓝牙耳机失败","date":"2021-04-08T14:28:40.000Z","updated":"2022-09-21T12:55:02.882Z","comments":true,"path":"2021/4/d33e602069a3/","link":"","permalink":"https://blog.ryaoknw.site/2021/4/d33e602069a3/","excerpt":"","text":"前言把Ubuntu18扬了后，重装Ubuntu20.04，莫名解决了在Ubuntu18上的一些问题，而耳机和brightness control的坑一直没碰，最近越发感到不能连接蓝牙耳机的不方面，终于解决，记录出来 正文系统：Ubuntu20.04 在设置-蓝牙中始终连接不上蓝牙耳机 方案一尝试安装blueman 1sudo apt install blueman 再打开blueman进行连接 失败 方案二控制台重启蓝牙服务 1sudo service bluetooth restart 打开蓝牙控制检查工作情况 12bluetoothctlshow 将会显示类似内容： 1234567891011121314151617181920212223242526272829303132333435Controller C8:B2:9B:F3:BB:27 (public) Name: ryao-Lenovo-Legion-Y7000P-2020H Alias: ryao-Lenovo-Legion-Y7000P-2020H Class: 0x001c010c Powered: yes Discoverable: yes DiscoverableTimeout: 0x00000000 Pairable: yes UUID: Message Notification Se.. (00001133-0000-1000-8000-00805f9b34fb) UUID: A/V Remote Control (0000110e-0000-1000-8000-00805f9b34fb) UUID: OBEX Object Push (00001105-0000-1000-8000-00805f9b34fb) UUID: Message Access Server (00001132-0000-1000-8000-00805f9b34fb) UUID: PnP Information (00001200-0000-1000-8000-00805f9b34fb) UUID: IrMC Sync (00001104-0000-1000-8000-00805f9b34fb) UUID: Vendor specific (00005005-0000-1000-8000-0002ee000001) UUID: Headset AG (00001112-0000-1000-8000-00805f9b34fb) UUID: A/V Remote Control Target (0000110c-0000-1000-8000-00805f9b34fb) UUID: Generic Attribute Profile (00001801-0000-1000-8000-00805f9b34fb) UUID: Phonebook Access Server (0000112f-0000-1000-8000-00805f9b34fb) UUID: Audio Sink (0000110b-0000-1000-8000-00805f9b34fb) UUID: Generic Access Profile (00001800-0000-1000-8000-00805f9b34fb) UUID: Headset (00001108-0000-1000-8000-00805f9b34fb) UUID: Audio Source (0000110a-0000-1000-8000-00805f9b34fb) UUID: OBEX File Transfer (00001106-0000-1000-8000-00805f9b34fb) Modalias: usb:v1D6Bp0246d0535 Discovering: noAdvertising Features: ActiveInstances: 0x00 SupportedInstances: 0x05 SupportedIncludes: tx-power SupportedIncludes: appearance SupportedIncludes: local-name SupportedSecondaryChannels: 1M SupportedSecondaryChannels: 2M SupportedSecondaryChannels: Coded 如果没有显示，那么蓝牙设备可能有问题，以下操作将不会解决问题 正常显示，则执行以下命令 1234agent ondefault-agentpower onpairable on 将设备调至配对模式，扫描设备 1scan on 显示设备 1devices 出现类似内容： 12345678910111213Device 00:0E:0E:16:20:FF 00-0E-0E-16-20-FFDevice 00:0E:0B:16:11:9F ZK#001#104Device 94:17:00:46:AC:8F Redmi K30 UltraDevice 10:63:C8:E8:26:DC 10-63-C8-E8-26-DCDevice EC:7E:FC:28:DD:3F Mi Smart Band 4Device 60:AB:67:79:3D:8D 1432412001的MI 9 SEDevice 00:0E:0B:16:20:FF 00-0E-0B-16-20-FFDevice 46:C9:D5:E7:84:A5 46-C9-D5-E7-84-A5Device 00:0E:0B:14:F3:08 00-0E-0B-14-F3-08Device 7C:2A:DB:54:4E:F6 7C-2A-DB-54-4E-F6Device 9C:6B:72:B0:FB:36 realme X2Device 00:00:12:44:48:34 ShanghaiTieTaWangDevice 6C:06:D6:2F:A5:C1 FreeBuds 3 安装pulseaudio-module-bluetooth（如果像我一样pair failed的话） 123sudo apt install pulseaudio-module-bluetooth pulseaudio -kpulseaudio --start 然后连接设备 123trust [MAC_ADDRESS]pair [MAC_ADDRESS]connect [MAC_ADDRESS] 终于成功 退出 1exit","categories":[{"name":"linux","slug":"linux","permalink":"https://blog.ryaoknw.site/categories/linux/"},{"name":"折腾","slug":"折腾","permalink":"https://blog.ryaoknw.site/categories/%E6%8A%98%E8%85%BE/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://blog.ryaoknw.site/tags/ubuntu/"}]},{"title":"Ubuntu踩坑：资源占用情况低但显示仍然卡顿","slug":"Ubuntu踩坑：资源占用情况低但显示仍然卡顿","date":"2021-04-08T10:46:53.000Z","updated":"2022-09-21T12:55:02.882Z","comments":true,"path":"2021/4/61aa3931e5e3/","link":"","permalink":"https://blog.ryaoknw.site/2021/4/61aa3931e5e3/","excerpt":"","text":"前言系统：Ubuntu20.04 以及 Ubuntu18.04 无论是拖动滑动条，还是播放视频，还是切换屏幕都会有间断性的卡顿 这是一个一直困扰我的问题，以至于我认为是Ubuntu自身的问题，我在Ubuntu的体验上一直不如windows上丝滑，他会有间断性的卡顿，以至于我感觉是帧率太低或者其他的原因 初步尝试过程我怀疑是nvidia驱动的问题，于是我尝试卸载并重新安装nvidia驱动，问题依然没有解决。于是我又更新了Ubuntu内核，但是无效 那么真的是帧率低吗 我尝试使用mesa-utils用glxgears来监视帧率，发现能够一直保持在140以上，这显然是不低的。 我又将nvidia驱动禁用，使用intel集显，但没有改变卡顿问题。 我将这个问题搁置又拾起了多次 解决在多次搜索之后竟然偶然在csdn上找到了一个相同的问题https://blog.csdn.net/qq_43334196&#x2F;article&#x2F;details&#x2F;107374390我发现我也安装了这个所谓的“系统监视器”，安装命令是 sudo apt install indicator-multiload （所以在你翻到这篇文章后一定不要用它了） 你在首选项中能找到这样的东西 于是它每次检测的时候你的界面就会卡顿一次，体验非常不好 于是卸载它就行了 但是我目前依然不清楚卡顿的内部原因，按道理检测系统资源是不会卡顿的，现在我的Ubuntu异常丝滑了","categories":[{"name":"linux","slug":"linux","permalink":"https://blog.ryaoknw.site/categories/linux/"},{"name":"折腾","slug":"折腾","permalink":"https://blog.ryaoknw.site/categories/%E6%8A%98%E8%85%BE/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://blog.ryaoknw.site/tags/ubuntu/"}]},{"title":"用go-cqhttp搭建qqbot","slug":"用go-cqhttp搭建qqbot","date":"2021-04-03T17:34:45.000Z","updated":"2022-09-21T12:55:02.882Z","comments":true,"path":"2021/4/2b48558f4b48/","link":"","permalink":"https://blog.ryaoknw.site/2021/4/2b48558f4b48/","excerpt":"前言好久没写博客了（同时前几篇也太水了），之前在折腾博客基建，这段时间也搞了一堆东西，虽然有记录，但是没时间整理一下然后写出来，刚好最近没有什么","text":"前言好久没写博客了（同时前几篇也太水了），之前在折腾博客基建，这段时间也搞了一堆东西，虽然有记录，但是没时间整理一下然后写出来，刚好最近没有什么 事，本来想实践一下微信小程序和微信公众号的开发，奈何没有成年，申请不了，于是被打回来写qqbot，本着好玩的目的，但是实践的过程中还是遇到了一些困难，由于缺乏基本认识而踩了一堆坑 QQ 协议端搭建没错，这个东西叫协议端！ 目前比较常见的有： go-cqhttp (基于 MiraiGo) cqhttp-mirai-embedded Mirai + cqhttp-mirai Mirai + Mirai Native + CQHTTP OICQ-http-api (基于 OICQ) 酷Q (已停止开发) （来自知乎） 我这里采用go-cqhttp，采用其他的基本也相同，最重要的是要基于onebot标准 关于如何搭建可以看文档 首先编写config.hjson文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/* go-cqhttp 默认配置文件*/&#123; // QQ号 uin: 0 // QQ密码 password: &quot;&quot; // 是否启用密码加密 encrypt_password: false // 加密后的密码, 如未启用密码加密将为空, 请勿随意修改. password_encrypted: &quot;&quot; // 是否启用内置数据库 // 启用将会增加10-20MB的内存占用和一定的磁盘空间 // 关闭将无法使用 撤回 回复 get_msg 等上下文相关功能 enable_db: true // 访问密钥, 强烈推荐在公网的服务器设置 access_token: &quot;&quot; // 重连设置 relogin: &#123; // 是否启用自动重连 // 如不启用掉线后将不会自动重连 enabled: true // 重连延迟, 单位秒 relogin_delay: 3 // 最大重连次数, 0为无限制 max_relogin_times: 0 &#125; // API限速设置 // 该设置为全局生效 // 原 cqhttp 虽然启用了 rate_limit 后缀, 但是基本没插件适配 // 目前该限速设置为令牌桶算法, 请参考: // https://baike.baidu.com/item/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/6597000?fr=aladdin _rate_limit: &#123; // 是否启用限速 enabled: false // 令牌回复频率, 单位秒 frequency: 1 // 令牌桶大小 bucket_size: 1 &#125; // 是否忽略无效的CQ码 // 如果为假将原样发送 ignore_invalid_cqcode: false // 是否强制分片发送消息 // 分片发送将会带来更快的速度 // 但是兼容性会有些问题 force_fragmented: false // 心跳频率, 单位秒 // -1 为关闭心跳 heartbeat_interval: 0 // HTTP设置 http_config: &#123; // 是否启用正向HTTP服务器 enabled: true // 服务端监听地址 host: 127.0.0.1 // 服务端监听端口 port: 22333 // 反向HTTP超时时间, 单位秒 // 最小值为5，小于5将会忽略本项设置 timeout: 0 // 反向HTTP POST地址列表 // 格式: // &#123; // 地址: secret // &#125; post_urls:&#123;&#125; &#125; // 正向WS设置 ws_config: &#123; // 是否启用正向WS服务器 enabled: false // 正向WS服务器监听地址 host: 127.0.0.1 // 正向WS服务器监听端口 port: 6700 &#125; // 反向WS设置 ws_reverse_servers: [ // 可以添加多个反向WS推送 &#123; // 是否启用该推送 enabled: true // 反向WS Universal 地址 // 注意 设置了此项地址后下面两项将会被忽略 // 留空请使用 &quot;&quot; reverse_url: ws://127.0.0.1:22334/ // 反向WS API 地址 reverse_api_url: ws://you_websocket_api.server // 反向WS Event 地址 reverse_event_url: ws://you_websocket_event.server // 重连间隔 单位毫秒 reverse_reconnect_interval: 3000 &#125; ] // 上报数据类型 // 可选: string array post_message_format: string // 是否使用服务器下发的新地址进行重连 // 注意, 此设置可能导致在海外服务器上连接情况更差 use_sso_address: false // 是否启用 DEBUG debug: false // 日志等级 trace,debug,info,warn,error log_level: &quot;info&quot; // WebUi 设置 web_ui: &#123; // 是否启用 WebUi enabled: false // 监听地址 host: 127.0.0.1 // 监听端口 web_ui_port: 9999 // 是否接收来自web的输入 web_input: false &#125;&#125; ./go-cqhttp运行后需要进行滑块认证，在浏览器抓取cap_union_new_verify 的返回值，然后把ticket的值输入就行了。 此时协议端搭建完毕 注：记得iptable开放相应端口 后端搭建一、使用机器人框架不得不说python的nonebot和nonebot2实在是太方便了，文档也十分详细。 如果你只是想要一个qqbot，推荐使用以上两个框架，大概几个小时就能实现一个bot 如果你想用go来写，也可以用ZeroBot来作为你的框架 二、写后端来调用协议虽然框架很好用（单指python的库） 但由于觉得好玩，我还是头铁地使用了go来开发 找不到真正合适的go开发框架，于是自己写websocket来对接 go websocket的使用请自行学习，这里简单描述搭建服务的过程，细节可以参考我的代码部分https://github.com/RyaoChengfeng/rinqqbot/blob/main/controller/ws.go http监听ws反向端口123456controller.StartWebsocket() err:= http.ListenAndServe(config.Addr+`:`+config.WsPort,nil) if err != nil &#123; fmt.Println(err) os.Exit(1) &#125; 将http升级为ws并启动ws12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152type wsConnection struct &#123; wsSocket *websocket.Conn // 底层websocket inChan chan *wsMessage // 读队列 outChan chan *wsMessage // 写队列 mutex sync.Mutex // 避免重复关闭管道,加锁处理 isClosed bool closeChan chan byte // 关闭通知 id int64 &#125;var upgrader = websocket.Upgrader&#123; ReadBufferSize: 1024, WriteBufferSize: 1024, // 允许所有的CORS 跨域请求，正式环境可以关闭 CheckOrigin: func(r *http.Request) bool &#123; return true &#125;, &#125;func StartWebsocket() &#123; WsConnAll = make(map[int64]*wsConnection) http.HandleFunc(&quot;/&quot;, wsHandler) &#125;func wsHandler(rsp http.ResponseWriter, req *http.Request) &#123; // 应答客户端告知升级连接为websocket wsSocket, err := upgrader.Upgrade(rsp, req, nil) if err != nil &#123; log.Logger.Error(&quot;升级为websocket失败&quot;, err.Error()) &#125; maxConnId++ // 连接数保持一定数量，超过的部分不提供服务 // 如果要控制连接数可以计算WsConnAll长度 len(WsConnAll) wsConn := &amp;wsConnection&#123; wsSocket: wsSocket, inChan: make(chan *wsMessage, 1000), outChan: make(chan *wsMessage, 1000), closeChan: make(chan byte), isClosed: false, id: maxConnId, &#125; WsConnAll[maxConnId] = wsConn // 处理器,发送定时信息，避免意外关闭 go processLoop(wsConn) // 读协程 go wsReadLoop(wsConn) // 写协程 go wsWriteLoop(wsConn) &#125; 在多线程中处理协议端发来的message，并提取信息进行调用协议端api123456err = json.Unmarshal(msg.data, &amp;msgData) if err != nil &#123; log.Logger.Error(&quot;json信息解析错误&quot;, err.Error()) &#125; //log.Logger.Debug(&quot;收到消息：&quot;,msgData) HandleWsMsg(msgData) 在HandleWsMsg中进行bot功能实现message结构请参考对应的协议文档，以及基于onebot标准的协议的onebot标准，具体参考下方链接 参考 go-cqhttp文档 Onebot标准","categories":[{"name":"CS","slug":"CS","permalink":"https://blog.ryaoknw.site/categories/CS/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://blog.ryaoknw.site/tags/%E6%95%99%E7%A8%8B/"},{"name":"go","slug":"go","permalink":"https://blog.ryaoknw.site/tags/go/"},{"name":"qqbot","slug":"qqbot","permalink":"https://blog.ryaoknw.site/tags/qqbot/"}]},{"title":"数据结构-1-链表","slug":"数据结构-1-链表","date":"2020-12-22T18:09:56.000Z","updated":"2022-09-21T12:55:02.882Z","comments":true,"path":"2020/12/2fb9b06514d1/","link":"","permalink":"https://blog.ryaoknw.site/2020/12/2fb9b06514d1/","excerpt":"","text":"单链表指针大法好 真正到学习数据结构的时候才发现自己对指针的特性理解得非常肤浅，在真正使用链表的时候卡了很久 核心 增 1234p=(Link*)malloc(sizeof (Link));p-&gt;data=*data++; //data为数据集合p-&gt;next=L-&gt;next;L-&gt;next=p; 删 1234Link *q;q=p-&gt;next;p-&gt;next=q-&gt;next;free(q); 查 1e=p-&gt;data; //e为节点data 插 12345Link *s;s=(Link*)malloc(sizeof(Link));s-&gt;data=e; //e为节点datas-&gt;next=p-&gt;next;p-&gt;next=s; 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef char Elemtype;struct Node&#123; Elemtype data; struct Node *next;&#125;;typedef struct Node Link;Link **head;Link **tail;// 先进后出linkvoid d_CreateLink(Link **L,Elemtype data[],int n)&#123; Link *p; int i; *L=(Link *)malloc(sizeof (Link)); (*L)-&gt;next=NULL; for (i = 0; i &lt; n; ++i) &#123; p=(Link*)malloc(sizeof (Link)); p-&gt;data=*data++; p-&gt;next=(*L)-&gt;next; (*L)-&gt;next=p; &#125;&#125;//先进先出linkvoid CreateLink(Link **L,Elemtype data[],int n) &#123; Link *p,*r; int i; *L=(Link *)malloc(sizeof (Link)); r=*L; for (i = 0; i &lt; n; i++) &#123; p=(Link*)malloc(sizeof (Link)); p-&gt;data=*data++; r-&gt;next=p; r=p; &#125; r-&gt;next=NULL;&#125;// 增量式单链表（正序）void AddLink(Link **L,Elemtype data[],int n) &#123; Link *p,*r; int i; if (tail!=NULL)&#123; r=*tail; &#125;else &#123; *L=(Link *)malloc(sizeof (Link)); r=*L; &#125; for (i = 0; i &lt; n; i++) &#123; p=(Link*)malloc(sizeof (Link)); p-&gt;data=*data++; r-&gt;next=p; r=p; &#125; r-&gt;next=NULL; *tail=r;&#125;// 得到第i个节点的dataElemtype GetElem(Link *L,int i,Elemtype e)&#123; int j; Link *p; p=L-&gt;next; j=1; while (p&amp;&amp;j&lt;i)&#123; p=p-&gt;next; j++; &#125; if (!p||j&gt;i)&#123; return -1; &#125; e=p-&gt;data; return e;&#125;// 在第i个节点之前插入新的node，L长度+1void InsertElem(Link *L,int i,Elemtype e) &#123; int j; Link *p,*s; p=L; j=1; while (p&amp;&amp;j&lt;i)&#123; p=p-&gt;next; ++j; &#125; if (!p||j&gt;i) &#123; return; &#125; s=(Link*)malloc(sizeof(Link)); s-&gt;data=e; s-&gt;next=p-&gt;next; p-&gt;next=s;&#125;Elemtype DeleteElem(Link *L,int i,Elemtype e)&#123; int j; Link *p,*q; p=L; j=1; while (p-&gt;next&amp;&amp;j&lt;i)&#123; p=p-&gt;next; j++; &#125; if (!(p-&gt;next)||j&gt;i)&#123; return -1; &#125; q=p-&gt;next; p-&gt;next=q-&gt;next; free(q); return e;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.ryaoknw.site/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.ryaoknw.site/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"线性表","slug":"线性表","permalink":"https://blog.ryaoknw.site/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.ryaoknw.site/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"算法题解(3)-贪心","slug":"算法题解-3-贪心","date":"2020-12-21T02:09:34.000Z","updated":"2022-09-21T12:55:02.882Z","comments":true,"path":"2020/12/0980416f6804/","link":"","permalink":"https://blog.ryaoknw.site/2020/12/0980416f6804/","excerpt":"","text":"P2240 【深基12.例1】部分背包问题好像只是数学问题，用单位价格排出性价比，取从大到小直到装满就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;struct mon&#123; int w,v; double bili;&#125;money[110];void swap(mon *a,mon *b)&#123; double t=a-&gt;bili; a-&gt;bili=b-&gt;bili; b-&gt;bili=t; int d=a-&gt;w; a-&gt;w=b-&gt;w; b-&gt;w=d; d=a-&gt;v; a-&gt;v=b-&gt;v; b-&gt;v=d;&#125;void quick_sort(mon arr[],int len) &#123; if (len &lt;= 1) return; srand((unsigned)time(nullptr)); const double pivot = arr[rand() % len].bili; int i = 0, j = 0, k = len; while (i &lt; k) &#123; if (arr[i].bili &gt; pivot)&#123; swap(&amp;arr[i], &amp;arr[j]); i++;j++;&#125; else if (pivot &gt; arr[i].bili)&#123; swap(&amp;arr[i], &amp;arr[k-1]); k--;&#125; else i++; &#125; quick_sort(arr, j); quick_sort(arr + k, len - k);&#125;int main()&#123; int n,bag; scanf(&quot;%d%d&quot;,&amp;n,&amp;bag); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d%d&quot;,&amp;money[i].w,&amp;money[i].v); if (money[i].w==0) money[i].bili=0; else money[i].bili=1.0*money[i].v/money[i].w; &#125; quick_sort(money,n); int i=0; double sum=0; while (bag&gt;=money[i].w)&#123; bag-=money[i].w; sum+=money[i].v; i++; &#125; sum+=bag*money[i].bili; printf(&quot;%.2lf&quot;,sum); return 0;&#125; P1090合并果子刚看到题目心想，这不就是个数学题嘛，排完序一个个加起来就好了，然后配合官方巨水的样例测一下后，一下就提交了。 之后陷入了疯狂tl和wa的窘境。 思路如下，要得到最小的花费体力值，先将原数据排序，再将其放到for中进行循环过程来加出sum的值，每次将父列的第一个加到第二个后都要再排一次序来得到新子列，这样才能保证最小 所以在里面用一个时间复杂度低的插入排序就可以解决问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;void swap(int *a,int *b)&#123; int t=*a; *a=*b; *b=t;&#125;void quick_sort(int arr[],int len) &#123; if (len &lt;= 1) return; srand((unsigned)time(NULL)); const int pivot = arr[rand() % len]; int i = 0, j = 0, k = len; while (i &lt; k) &#123; if (arr[i] &lt; pivot)&#123; swap(&amp;arr[i], &amp;arr[j]); i++;j++;&#125; else if (pivot &lt; arr[i])&#123; swap(&amp;arr[i], &amp;arr[k-1]); k--;&#125; else i++; &#125; quick_sort(arr, j); quick_sort(arr + k, len - k);&#125;void shell_sort(int arr[], int length) &#123; int h = 1; while (h &lt; length / 3) &#123; h = 3 * h + 1; &#125; while (h &gt;= 1) &#123; for (int i = h; i &lt; length; i++) &#123; for (int j = i; j &gt;= h &amp;&amp; arr[j] &lt; arr[j - h]; j -= h) &#123; swap(&amp;arr[j], &amp;arr[j - h]); &#125; &#125; h = h / 3; &#125;&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int guo[n+5]; guo[n]=0; for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;,&amp;guo[i]); &#125; int sum=0; int tili; quick_sort(guo,n); for (int i = 0; i &lt; n-1; ++i) &#123; shell_sort((guo+i),n-i); tili=0; tili+=(guo[i+1]+guo[i]); guo[i+1]+=guo[i]; sum+=tili; &#125; printf(&quot;%d&quot;,sum);&#125; P1223 排队接水本是是很简单问题，莫名出了错 思路是先排序，再把时间加起来，再求平均就可以了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#include &lt;algorithm&gt;struct per &#123; int index; int time;&#125;person[2000];void swap(per *a,per *b)&#123; int t=a-&gt;time; a-&gt;time=b-&gt;time; b-&gt;time=t; t=a-&gt;index; a-&gt;index=b-&gt;index; b-&gt;index=t;&#125;void quick_sort(per arr[],int len) &#123; if (len &lt;= 1) return; srand((unsigned)time(NULL)); const int pivot = arr[rand() % len].time; int i = 0, j = 0, k = len; while (i &lt; k) &#123; if (arr[i].time &lt; pivot)&#123; swap(&amp;arr[i], &amp;arr[j]); i++;j++;&#125; else if (pivot &lt; arr[i].time)&#123; swap(&amp;arr[i], &amp;arr[k-1]); k--;&#125; else i++; &#125; quick_sort(arr, j); quick_sort(arr + k, len - k);&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); for (int i = 0; i &lt; n; ++i) &#123; person[i].index=i+1; scanf(&quot;%d&quot;,&amp;person[i].time); &#125; quick_sort(person,n); for (int i = 0; i &lt; n; ++i) &#123; printf(&quot;%d &quot;,person[i].index); &#125; printf(&quot;\\n&quot;); double sum=0; int shijian=0; for (int i = 0; i &lt; n-1; ++i) &#123; shijian+=person[i].time; sum+=shijian; &#125; printf(&quot;%.2lf\\n&quot;,1.0*sum/n); //?????我卡了半天,后面的1.0*sum/n是原本就有的,sum是int类型。 //然后本是int的sum变成double,去掉了1.0,就又过了两个，但是第一个却过不了。 //把1.0加上，就全部过了。离谱&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.ryaoknw.site/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.ryaoknw.site/tags/%E7%AE%97%E6%B3%95/"},{"name":"贪心","slug":"贪心","permalink":"https://blog.ryaoknw.site/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"算法题解(2)-二分","slug":"算法题解-2-二分","date":"2020-12-11T19:30:50.000Z","updated":"2022-09-21T12:55:02.882Z","comments":true,"path":"2020/12/4cd8ae11fe0e/","link":"","permalink":"https://blog.ryaoknw.site/2020/12/4cd8ae11fe0e/","excerpt":"","text":"洛谷P1873 砍树123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#define MAX(a, b) a&gt;b?a:b#define MIN(a, b) a&gt;b?b:aint main() &#123; long long N, M, mid, length; scanf(&quot;%lld %lld&quot;, &amp;N, &amp;M); long long l = 0, s = 1000000000; long long height[N]; for (int i = 0; i &lt; N; ++i) &#123; scanf(&quot;%lld&quot;, &amp;height[i]); l = MAX(height[i], l); s = MIN(height[i], s); &#125; mid = s + ((l - s) &gt;&gt; 1); while (s + 1 &lt; l) &#123; length = 0; for (int i = 0; i &lt; N; ++i) &#123; if (mid &lt; height[i]) length += height[i] - mid; &#125; if (length &gt;= M) &#123; s = mid; mid = s + ((l - s) &gt;&gt; 1); &#125; else &#123; l = mid; mid = s + ((l - s) &gt;&gt; 1); &#125; &#125; printf(&quot;%lld&quot;, mid); return 0;&#125; 洛谷P2249 【深基13.例1】查找就是写二分，但是要注意输出最左边，也就是最小的，怎么找出左边界需要想一下（于是我一直wa 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;int find(int arr[], int len, int value) &#123; int l = 1, r = len; int mid; while (l&lt;r) &#123; mid =l + (r-l)/2; if (arr[mid] &lt; value) l = mid+1; else r = mid; &#125; if (arr[l]==value) return l; else return -1;&#125;int main() &#123; int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int number[n+3]; for (int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%d&quot;,&amp;number[i]); &#125; int value; int index; for (int i = 0; i &lt; m; ++i) &#123; scanf(&quot;%d&quot;,&amp;value); index=find(number,n,value); printf(&quot;%d &quot;,index); &#125; return 0;&#125; 洛谷P1678 烦恼的高考志愿123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;int min(int a,int b)&#123; int min; if (a&lt;b)min=a; else min=b; return min;&#125;int main()&#123; int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int school[n+5]; for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;,&amp;school[i]); &#125; std::sort(school,school+n); int stu[m+5]; for (int i = 0; i &lt; m; ++i) &#123; scanf(&quot;%d&quot;,&amp;stu[i]); &#125; int sum = 0; for (int i = 0; i &lt; m; ++i) &#123; int l=0,r=n; while(l&lt;r)&#123; int mid=(l+r)/2; if(school[mid]&lt;=stu[i])&#123; l=mid+1; &#125;else&#123; r=mid; &#125; &#125; if(stu[i]&lt;=school[0])&#123; sum+=school[0]-stu[i]; &#125; else&#123; sum+=min(abs(school[l-1]-stu[i]),abs(school[l]-stu[i])); &#125; &#125; printf(&quot;%d&quot;,sum); return 0;&#125; P2440 木材加工和砍树问题的思路一样，另写一个函数来判断是否符合要求，然后用二分法确定最大的值即可 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;long long n, k;long long a[1000005];bool jd(long long x) &#123; long long sum = 0; for (int i = 1; i &lt;= n; i++) &#123; sum += a[i] / x; &#125; if (sum&gt;=k)&#123; return true; &#125; return false;&#125;int main() &#123; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%lld&quot;,&amp;a[i]); &#125; long long l = 0, r = 100000001; long long mid; while (l + 1 &lt; r) &#123; mid = l+(r-l)/2; if (jd(mid)) &#123; l = mid; &#125; else r = mid; &#125; printf(&quot;%lld&quot;,l); return 0;&#125; P2678 跳石头同样的二分套路，这里定义了所在石头和下一个石头，mid大于间距时，将石头搬走，同时计数，mid小与或等于间距时，进入下一个石头。当搬走的总数要小于预计的数目时，证明mid偏小，将left右移，否则right左移，最终得到正确的mid。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;long num[100000];long l,n,m,dis=0,first=0,end;int jd(long mid)&#123; long sum=0; int i=1; int temp=0; while(i &lt;= n)&#123; first=num[temp]; end=num[i]; dis=end-first; if (dis&lt;mid)&#123; sum++; &#125; else temp=i; i++; &#125; if (sum&lt;=m)&#123; return 1; &#125; else return 0;&#125;int main()&#123; scanf(&quot;%ld%ld%ld&quot;,&amp;l,&amp;n,&amp;m); num[0]=0; for (long i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%ld&quot;,&amp;num[i]); &#125; long left=0,right=l,mid,rst; while (left&lt;=right)&#123; mid=left+(right-left)/2; if (jd(mid))&#123; rst=mid; left=mid+1; &#125;else right=mid-1; &#125; printf(&quot;%ld&quot;,rst);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.ryaoknw.site/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.ryaoknw.site/tags/%E7%AE%97%E6%B3%95/"},{"name":"二分查找","slug":"二分查找","permalink":"https://blog.ryaoknw.site/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"算法题解(1)-排序","slug":"算法题解-1-排序","date":"2020-12-10T18:19:15.000Z","updated":"2022-09-21T12:55:02.882Z","comments":true,"path":"2020/12/a7d68e1b79ca/","link":"","permalink":"https://blog.ryaoknw.site/2020/12/a7d68e1b79ca/","excerpt":"","text":"排序（c++）虽然是c++，其实是c语法 洛谷P1271 选举学生会已经得知了数据范围，使用桶排序 123456789101112131415161718192021#include &lt;cstdio&gt;int main() &#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int num; int bucket[n+1]; for (int i = 0; i &lt; n+1; ++i) &#123; bucket[i] = 0; &#125; for (int i = 0; i &lt; m; ++i) &#123; scanf(&quot;%d&quot;, &amp;num); bucket[num] += 1; &#125; for (int i = 0; i &lt; n+1; ++i) &#123; for (int j = 0; j &lt; bucket[i]; ++j) &#123; printf(&quot;%d &quot;,i); &#125; &#125;&#125; 洛谷P1923 找出第k小的数练习快排和分治 判断排序后两边数组长度，选择一边进行递归 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;ctime&gt;// 注意题目中最小数序号是0void swap(int *a,int *b)&#123; int t=*a; *a=*b; *b=t;&#125;int findi_quicksort(int arr[],int len,int index)&#123; if (len&lt;=1) return arr[0]; srand((unsigned)time(NULL)); const int temp = arr[rand() % len]; int i=0,j=0,k=len; while (i&lt;k)&#123; if (arr[i] &lt; temp)&#123; swap(&amp;arr[i], &amp;arr[j]); i++;j++;&#125; else if (temp &lt; arr[i])&#123; swap(&amp;arr[i], &amp;arr[k-1]); k--;&#125; else i++; &#125; if (index&lt;j) return findi_quicksort(arr, j,index); else if (index&gt;=k) return findi_quicksort(arr + k, len - k,index-k); else return temp;&#125;int main()&#123; int n,i; scanf(&quot;%d%d&quot;,&amp;n,&amp;i); int number[n]; for (int j = 0; j &lt; n; ++j) &#123; scanf(&quot;%d&quot;,&amp;number[j]); &#125; printf(&quot;%d&quot;,findi_quicksort(number,n,i));&#125; 洛谷P1059 明明的随机数数据范围不大，可以用桶排序 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;int bucket[1001];int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); int number; for (int &amp;i : bucket) &#123; i = 0; &#125; for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;, &amp;number); bucket[number]++; &#125; int count = 0; for (int i = 0; i &lt; 1001; ++i) &#123; if (bucket[i] &gt; 0) &#123; count++; &#125; &#125; printf(&quot;%d\\n&quot;,count); for (int i = 0; i &lt; 1001; ++i) &#123; if (bucket[i] &gt; 0) &#123; count++; printf(&quot;%d &quot;, i); &#125; &#125;&#125; P1059重新想了一下，也可以用快排 排序完后检测重复然后跳过就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;ctime&gt;void swap(int*a,int*b)&#123; int t=*a; *a=*b; *b=t;&#125;void quicksort(int arr[],int len)&#123; if (len&lt;=1) return; srand((unsigned)time(NULL)); const int temp = arr[rand() % len]; int i=0,j=0,k=len; while (i&lt;k)&#123; if (arr[i]&lt;temp)&#123; swap(&amp;arr[i],&amp;arr[j]); j++; i++; &#125; else if(temp&lt;arr[i])&#123; swap(&amp;arr[i],&amp;arr[k-1]); k--; &#125; else i++; &#125; quicksort(arr,j); quicksort(arr+k,len-k);&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int number[n+1]; for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;,&amp;number[i]); &#125; number[n+1]=-1; quicksort(number,n); int cnt=0; for (int i = 0; i &lt; n; ++i) &#123; cnt++; if (number[i]==number[i+1]) cnt--; &#125; printf(&quot;%d\\n&quot;,cnt); for (int i = 0; i &lt; n; ++i) &#123; if (number[i] != number[i + 1]) printf(&quot;%d &quot;, number[i]); &#125; return 0;&#125; 洛谷P1093 奖学金结构体排序问题，挺有收获的，语法和算法方面。 先用快排排好结构体。注意写对swap函数 然后用冒泡排序的思想排出2,3条件即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;struct stu &#123; int index; int cn, mh, en; int sum;&#125; student[310];// 为什么用位运算交换就会错？void swap(stu *a, stu *b) &#123; int t=a-&gt;sum; a-&gt;sum=b-&gt;sum; b-&gt;sum=t; t=a-&gt;cn; a-&gt;cn=b-&gt;cn; b-&gt;cn=t; t=a-&gt;index; a-&gt;index=b-&gt;index; b-&gt;index=t;&#125;void quicksort(stu arr[], int len) &#123; if (len &lt;= 1) return; srand((unsigned) time(NULL)); const int temp = arr[rand() % len ].sum; int i = 0, j = 0, k = len; while (i &lt; k) &#123; if (arr[i].sum &gt; temp) &#123; swap(&amp;arr[i], &amp;arr[j]); i++; j++; &#125; else if (temp &gt; arr[i].sum) &#123; swap(&amp;arr[i], &amp;arr[k - 1]); k--; &#125; else i++; &#125; quicksort(arr, j); quicksort(arr + k, len - k);&#125;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; ++i) &#123; student[i].index = i + 1; scanf(&quot;%d %d %d&quot;, &amp;student[i].cn, &amp;student[i].mh, &amp;student[i].en); student[i].sum = student[i].cn + student[i].en + student[i].mh; &#125; quicksort(student, n); int in = 0; while (in == 0) &#123; in = 1; for (int i = 0; i &lt; n; ++i) &#123; if (student[i].sum == student[i + 1].sum) &#123; if (student[i].cn &lt; student[i + 1].cn) &#123; swap(&amp;student[i], &amp;student[i + 1]); in = 0; &#125; else if (student[i].cn == student[i + 1].cn &amp;&amp; student[i].index &gt; student[i + 1].index) &#123; swap(&amp;student[i], &amp;student[i + 1]); in = 0; &#125; &#125; &#125; &#125; for (int i = 0; i &lt; 5; ++i) &#123; printf(&quot;%d %d\\n&quot;, student[i].index, student[i].sum); &#125; return 0;&#125; 洛谷P1781 宇宙选举本来以为非常简单，但是发现涉及大整数处理（如果用python这种就丝毫没有问题） 只要选出一个，所以找出max就可以了，应该不用排序 感觉指针这种东西挺奇妙，结构体配上数组直接整死我。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;struct per&#123; int index; char vote[1000];&#125;person[25];per max(per a,per b)&#123; if (strlen(a.vote)&gt;strlen(b.vote)) return a; else if (strlen(a.vote)&lt;strlen(b.vote)) return b; else &#123; if (strcmp(a.vote, b.vote) &gt; 0) &#123; return a; &#125; else return b; &#125;&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); for (int i = 0; i &lt; n; ++i) &#123; person[i].index=i+1; scanf(&quot;%s&quot;,person[i].vote); &#125; strcpy(person[24].vote,person[0].vote); person[24].index=person[0].index; for (int i = 0; i &lt; n; ++i) &#123; person[24].index=max(person[24],person[i]).index; strcpy(person[24].vote,max(person[24],person[i]).vote); &#125; printf(&quot;%d\\n&quot;,person[24].index); printf(&quot;%s&quot;,person[24].vote); return 0;&#125; 洛谷P1104 生日可以用结构体做，用快排，之前写过一个了，不过这次想用c++的sort()试一下，就当自己练练c++的语法。 自己写一个cmp就可以了 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt; //万能头文件using namespace std; //没有这个底下的就都要std::struct per &#123; string s; int y, m, d, index;&#125; person[200];bool cmp(per a, per b) &#123; if (a.y &lt; b.y)return 1; if (a.y &gt; b.y)return 0; if (a.y == b.y) &#123; if (a.m &lt; b.m)return 1; if (a.m &gt; b.m)return 0; if (a.m == b.m) &#123; if (a.d &lt; b.d)return 1; if (a.d &gt; b.d)return 0; if (a.d == b.d) &#123; if (a.index &gt; b.index)return 1; else return 0; &#125; &#125; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; person[i].s &gt;&gt; person[i].y &gt;&gt; person[i].m &gt;&gt; person[i].d; person[i].index = i; &#125; sort(person + 1, person + n + 1, cmp); for (int i = 1; i &lt;= n; i++)cout &lt;&lt; person[i].s &lt;&lt; endl; return 0;&#125; 反思：这种题可以用数学思维附上加权，然后排序就可以了，（通俗说就是加权加到一科考好就可以在其他科不考的情况下卷赢其他人） 貌似要多条件排序都可以这样做，比如 year*10000+mouth*100+day 如果部分条件是倒序就减掉就可以了: score*10000+(10000-index) 洛谷P1116 车厢重组冒泡排序，加个count就可以了，单纯想熟悉一下 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;void swap(int*a,int*b)&#123; int t = *a; *a=*b; *b=t;&#125;int cnt=0;void bubble_sort(int arr[], int n) &#123; int in = 1; while (in) &#123; in = 0; for (int i = 0; i &lt; n-1; ++i) &#123; if (arr[i] &gt; arr[i + 1]) &#123; in = 1; cnt++; swap(&amp;arr[i],&amp;arr[i+1]); &#125; &#125; &#125;&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int car[n+1]; for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;,&amp;car[i]); &#125; bubble_sort(car,n); printf(&quot;%d&quot;,cnt); return 0;&#125; 洛谷P1068 分数线划定又是结构体。。。那就用加权吧（ 要注意weight[d-1]，用d就错了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;int weight[5010];void swap(int *a,int *b)&#123; int t=*a; *a=*b; *b=t;&#125;void quicksort(int arr[],int len) &#123; if (len &lt;= 1) return; srand((unsigned)time(NULL)); const int pivot = arr[rand() % len]; int i = 0, j = 0, k = len; while (i &lt; k) &#123; if (arr[i] &gt; pivot)&#123; swap(&amp;arr[i], &amp;arr[j]); i++;j++;&#125; else if (pivot &gt; arr[i])&#123; swap(&amp;arr[i], &amp;arr[k-1]); k--;&#125; else i++; &#125; quicksort(arr, j); quicksort(arr + k, len - k);&#125;int main()&#123; int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int a,b; for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); weight[i]=(b+1)*10000-a; &#125; quicksort(weight,n); int d=(int)m*1.5; int score=weight[d-1]/10000; while (weight[d-1]/10000==score) &#123; d++; &#125; d--; printf(&quot;%d %d\\n&quot;,weight[d-1]/10000,d); int i=0; while (weight[i]/10000&gt;=score)&#123; printf(&quot;%d %d\\n&quot;,10000-weight[i]%10000,weight[i]/10000); i++; &#125;&#125; 洛谷P5143 攀爬者又是结构体？感觉挺简单，却是个提高题 用加权，然后把距离加起来就可以了 后面的测试数据好大，用longlong 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;void swap(long long *a,long long *b)&#123; long long t=*a; *a=*b; *b=t;&#125;void quick_sort(long long arr[],long long len) &#123; if (len &lt;= 1) return; srand((unsigned)time(NULL)); const long long pivot = arr[rand() % len]; long long i = 0, j = 0, k = len; while (i &lt; k) &#123; if (arr[i] &lt; pivot)&#123; swap(&amp;arr[i], &amp;arr[j]); i++;j++;&#125; else if (pivot &lt; arr[i])&#123; swap(&amp;arr[i], &amp;arr[k-1]); k--;&#125; else i++; &#125; quick_sort(arr, j); quick_sort(arr + k, len - k);&#125;int main()&#123; long long n; scanf(&quot;%lld&quot;,&amp;n); long long location[n+1]; long long x,y,z; for (long long i = 0; i &lt; n; ++i) &#123; scanf(&quot;%lld%lld%lld&quot;,&amp;x,&amp;y,&amp;z); location[i]=z*100000000+y*10000+x; &#125; quick_sort(location,n); long double sum=0; for (long long i = 0; i &lt; n-1; ++i) &#123; long long z1=location[i]/100000000; long long y1=(location[i]%100000000)/10000; long long x1=(location[i]%100000000)%10000; long long z2=location[i+1]/100000000; long long y2=(location[i+1]%100000000)/10000; long long x2=(location[i+1]%100000000)%10000; sum+=sqrt(1.0*((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)+(z2-z1)*(z2-z1))); &#125; printf(&quot;%.3Lf&quot;,sum); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.ryaoknw.site/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://blog.ryaoknw.site/tags/%E6%8E%92%E5%BA%8F/"},{"name":"算法","slug":"算法","permalink":"https://blog.ryaoknw.site/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"用hexo搭建个人网站","slug":"用hexo搭建个人网站","date":"2020-12-07T11:45:40.000Z","updated":"2022-09-21T12:55:02.882Z","comments":true,"path":"2020/12/c03d6b73cca7/","link":"","permalink":"https://blog.ryaoknw.site/2020/12/c03d6b73cca7/","excerpt":"","text":"用hexo搭建个人网站前言未成年，所以域名无法备案，然后网站前几天挂了，本来想用来做新生实践课的大作业，然而ddl 来了，网站却用不了 虽然我启用了81端口，nginx也监听了相应端口，然而WordPress却没有改配置（踩坑）。于是进去后就只是一个html。。WordPress管理端是默认端口，于是也没办法管了，只好迅速配一个hexo，刚好自己也准备做一个，只不过太忙了（所以现在更忙了，淦） 开始你需要github或者gitee的账号，以及git的基本操作知识 我的环境是Ubuntu。 要求：最新版本的nodejs、npm、git。具体安装 or 更新方法不在此赘述。 请在自己的电脑上！而不是云服务器！ 使用npm安装hexo 1sudo npm install -g hexo -cil 建站请全部用sudo（不然会出现权限问题） 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 若报错: 123456console.js:39throw new ERR_CONSOLE_WRITABLE_STREAM(&#x27;stdout&#x27;);^TypeError [ERR_CONSOLE_WRITABLE_STREAM]: Console expects a writable stream instance for stdout...... 请更新npm和nodejs 同时请保证文件夹内是空的！ 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml：网站的 配置 信息，您可以在此配置大部分的参数 启动服务器。在路径下，命令行（即Git Bash）输入以下命令，运行即可： 1hexo server 浏览器访问网址： http://localhost:4000/ 至此，您的Hexo博客已经搭建在本地。 部署gitee新建仓库，名为自己的用户名 进入项目文件夹： 1sudo vim _config.yml 编辑theme来修改主题 1theme: volantis 终端输入（要在项目文件夹）： 1npm i hexo-theme-volantis 编辑_config.yml ： 1234deploy: type: git repo: git@gitee.com:himmi/himmi.git #或者https等等 branch: master 安装插件,要在站点目录下执行以上安装: 1sudo npm install hexo-deployer-git --save 如果已经在其他目录安装了hexo-deployer-git插件，可以使用以下命令卸载该插件： 1npm uninstall hexo-deployer-git --save 然后 1sudo hexo deploy 至此，部署完毕。 剩下的配置请参考hexo的doc，主题的配置参考各自的doc（其实配置才是折腾的地方） 参考https://hexo.io/zh-cn/ https://www.simon96.online/2018/10/12/hexo-tutorial/ https://gitee.com/help/articles/4136#article-header3 https://blog.csdn.net/mqdxiaoxiao/article/details/95781368 https://segmentfault.com/a/1190000011203711","categories":[{"name":"CS","slug":"CS","permalink":"https://blog.ryaoknw.site/categories/CS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.ryaoknw.site/tags/hexo/"}]},{"title":"为网站配置https/http2","slug":"为网站配置https-http2","date":"2020-11-14T23:06:01.000Z","updated":"2020-11-15T07:06:01.000Z","comments":true,"path":"2020/11/7b98a429154f/","link":"","permalink":"https://blog.ryaoknw.site/2020/11/7b98a429154f/","excerpt":"","text":"前言之前建站的时候就配过了一次了，刚好新人任务有要求，就简单记录一下 https由于传输原理的问题会比http要慢，在2012年谷歌提出SPDY的方案来应对https存在的延迟等问题。http2相比于https有了一些新特性。于是这里配置http2. 配置http2使用免费的Let’s Encrypt，在官网中会告诉你用 Certbot ACME 客户端自动配置，进去选择自己的nginx版本和系统版本就好了。页面上会出现操作步骤。 12sudo snap install core;sudo snap refresh core 1sudo snap install --classic certbot 1sudo ln -s /snap/bin/certbot /usr/bin/certbot 1sudo certbot --nginx 于是certbot就自动配置好nginx 使用这个来自动续订： 1sudo certbot renew --dry-run 我们也可以手动折腾一下。 申请证书： 1sudo certbot --nginx --register-unsafely-without-email certonly 选择对应的nginx配置文件（注意，它需要是正确可用的配置，可以执行sudo nginx -t来检查配置），此后letsencrypt证书将会自动生成在/etc/letsencrypt/live/your_conf_file中。 基本配置: 1234567891011121314server &#123; listen 80; server_name yoursite; return 301 https://$host$request_uri; &#125; server &#123; listen 443 ssl http2; server_name yoursite; ssl_certificate /etc/letsencrypt/live/your_conf_file/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/your_conf_file/privkey.pem; include /etc/letsencrypt/options-ssl-nginx.conf; ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;&#125; 此时https已配置完成。 禁止不安全的协议: 1ssl_ciphers &#x27;ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES256-GCM-SHA384:AES128-GCM-SHA256:AES256-SHA256:AES128-SHA256:AES256-SHA:AES128-SHA:DES-CBC3-SHA:HIGH:!aNULL:!eNULL:!EXPORT:!CAMELLIA:!DES:!MD5:!PSK:!RC4&#x27;; 启用HSTS: 12ssl_prefer_server_ciphers on; add_header Strict-Transport-Security max-age=15768000; 123456server &#123; listen 80; server_name yoursite;add_header Strict-Transport-Security max-age=15768000; return 301 https://$server_name$request_uri; &#125; 其他的安全配置 缓存连接凭据: 12ssl_session_cache shared:SSL:20m;ssl_session_timeout 60m; 配置赫尔曼密钥: 12openssl dhparam -out dhparam.pem 2048 #在 ssh 运行， openssl 生成 2048 位的密钥而不是当作参数写入 nginx.conf 文件ssl_dhparam /path/to/dhparam.pem; #在 .conf 中配置 OCSP 缝合 1234ssl_stapling on;ssl_stapling_verify on; ssl_trusted_certificate /etc/nginx/cert/trustchain.crt; resolver 233.5.5.5 233.6.6.6 valid=300s;","categories":[{"name":"CS","slug":"CS","permalink":"https://blog.ryaoknw.site/categories/CS/"}],"tags":[{"name":"http","slug":"http","permalink":"https://blog.ryaoknw.site/tags/http/"},{"name":"nginx","slug":"nginx","permalink":"https://blog.ryaoknw.site/tags/nginx/"}]},{"title":"note:图解HTTP(1)","slug":"note-图解HTTP-1","date":"2020-11-07T10:21:27.000Z","updated":"2020-11-07T18:21:27.000Z","comments":true,"path":"2020/11/e7a4c959b321/","link":"","permalink":"https://blog.ryaoknw.site/2020/11/e7a4c959b321/","excerpt":"","text":"报文和实体的差别关于第三章中报文和实体的差别，书中讲得太简洁。 报文要么是一个请求报文，要么就是一个响应报文。 一次传输中，在应用层来看，就是一个传输的单位（客户端请求服务器，是发送一个“请求报文”，服务器响应客户端，则发送“响应报文”），即为书中说的： 报文是HTTP通信中的基本单位，通过HTTP通信传输 实体其实是报文的一部分，存在于报文主体内 如一个GET请求报文中，就没有报文主体。那么这种情况下，也就不存在实体 实体是作为请求或响应的有效载荷数据被传输 那么在如响应报文中有： 123HTTP/1.1 200 OKContent-Type: text/plain Content-Length: 5 1234 那么1234就是实体。 实体的内容由实体首部和实体主体组成： 实体头部不一定会有。如上面“1234”这部分内容，就只有实体主体，没有实体头部。实体主体也确实等同于报文主体：在没有实体头部的时候就是这样 需要实体头部的场合，则是“传输中需要进行编码操作”的时候，如传输表单内容： 12345678910POST /upload HTTP/1.1 Host: example.com Content-Length: xxx Content-Type: multipart/form-data; boundary=AaBbCcDd --AaBbCcDd Content-Disposition: form-data; name=&quot;username&quot; RuphiLau --AaBbCcDd Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;picture.jpg&quot; Content-Type: image/jpeg ...(picture.jpg的数据)... --AaBbCcDd-- 这个报文里有多个实体 实体里，也有实体头部、实体主体，同样是通过CR+LF分割。 在现在的http协议下，传输编码只有一种：Transfer-Encoding: chunked 在其他任何情况下，实体&#x3D;实体主体 而这就刚好对应了上文的：编码提升效率 也就是说,当实体(像图片,文本这种数据的载体)不进行编码时,传输数据按照原貌直接传输,报文主体和实体主体是同一样东西.但是为了提高传输效率,要对实体进行编码 比如说:一个图片按原文传输需要5个字节,编码以后传输就是3个字节了,相当于主体内容已经改变了,但是报文主体是不变的,已经发生了变化 HSTS HTTP Strict Transport Security（HSTS）告诉浏览器只能通过HTTPS访问当前资源，而不是HTTP 配置： 123Strict-Transport-Security: max-age=&lt;expire-time&gt;Strict-Transport-Security: max-age=&lt;expire-time&gt;; includeSubDomainsStrict-Transport-Security: max-age=&lt;expire-time&gt;; preload 简介 一个网站接受一个HTTP的请求，然后跳转到HTTPS，用户可能在开始跳转前，通过没有加密的方式和服务器对话，比如，用户输入http://foo.com 或者直接 foo.com。 这样存在中间人攻击潜在威胁，跳转过程可能被恶意网站利用来直接接触用户信息，而不是原来的加密信息。 网站通过HTTP Strict Transport Security通知浏览器，这个网站禁止使用HTTP方式加载，浏览器应该自动把所有尝试使用HTTP的请求自动替换为HTTPS请求 处理步骤 你的网站第一次通过HTTPS请求，服务器响应Strict-Transport-Security 头，浏览器记录下这些信息，然后后面尝试访问这个网站的请求都会自动把HTTP替换为HTTPS。 当HSTS头设置的过期时间到了，后面通过HTTP的访问恢复到正常模式，不会再自动跳转到HTTPS。 每次浏览器接收到Strict-Transport-Security头，它都会更新这个网站的过期时间，所以网站可以刷新这些信息，防止过期发生。 Chrome、Firefox等浏览器里，当您尝试访问该域名下的内容时，会产生一个307 Internal Redirect（内部跳转），自动跳转到HTTPS请求","categories":[{"name":"CS","slug":"CS","permalink":"https://blog.ryaoknw.site/categories/CS/"}],"tags":[{"name":"http","slug":"http","permalink":"https://blog.ryaoknw.site/tags/http/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://blog.ryaoknw.site/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"解决网站配置完https后访问http失败","slug":"解决网站配置完https后访问http失败","date":"2020-11-05T23:53:49.000Z","updated":"2020-11-06T07:53:49.000Z","comments":true,"path":"2020/11/bbf6c1bf9db3/","link":"","permalink":"https://blog.ryaoknw.site/2020/11/bbf6c1bf9db3/","excerpt":"","text":"报错如下： 解决办法： 在nginx里配置，让请求http的时候跳转到https就可以啦 12345server &#123; listen 80;server_name ryaoknw.site; return 301 https://$server_name$request_uri; &#125; 注意启用https和http的时候要把80和433端口开放 之后看了一下各个网站，采用的方式也是把http跳转到 https 发现也可以直接在配置ssl的server块中监听80端口，自己当时的理解错了，url里的http和https只是指定协议，域名依旧是dns解析出来的ip地址，只要改一下端口就好了","categories":[{"name":"报错","slug":"报错","permalink":"https://blog.ryaoknw.site/categories/%E6%8A%A5%E9%94%99/"}],"tags":[{"name":"http","slug":"http","permalink":"https://blog.ryaoknw.site/tags/http/"},{"name":"nginx","slug":"nginx","permalink":"https://blog.ryaoknw.site/tags/nginx/"}]},{"title":"Hello, World!","slug":"hello-world","date":"2020-11-05T00:59:07.000Z","updated":"2020-11-05T08:59:07.000Z","comments":true,"path":"2020/11/f953da04e2b2/","link":"","permalink":"https://blog.ryaoknw.site/2020/11/f953da04e2b2/","excerpt":"历经曲折，折腾了一个晚上加上一个下午，终于把博客建出来了。准备手动搭建环境，装好了nginx和mysql，php，但是最后的phpmyadmin总是有迷之问题，折腾了好久最终放弃 之后使用云帮手来无脑搭环境，然而云帮手果然出了各种问题。。。无奈之下回到了最初的宝塔面板，装好环境后自己搭了WordPress，配了ssl和","text":"历经曲折，折腾了一个晚上加上一个下午，终于把博客建出来了。准备手动搭建环境，装好了nginx和mysql，php，但是最后的phpmyadmin总是有迷之问题，折腾了好久最终放弃 之后使用云帮手来无脑搭环境，然而云帮手果然出了各种问题。。。无奈之下回到了最初的宝塔面板，装好环境后自己搭了WordPress，配了ssl和 域名解析。期间域名解析配错了，又折腾了好久（还有v2ray开全局代理访问会爆500啊！）收获就是之后重装都异常熟练 再就是欢乐地选主题，换了三个siren，sakura和krato，而且最终也没有和ks和zcy一样用kale。还是用了krato，然后稍微折腾一下就成功了 算是完成了自己的一个浪漫。不过还是想之后有时间写静态页面的博客，但是最近ddl太！多！了！从开学到现在作息非常极客！急需时间管理大法。 之后有时间要陆陆续续地把自己的东西整理一下，搬到博客上来","categories":[{"name":"未分类","slug":"未分类","permalink":"https://blog.ryaoknw.site/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[]}],"categories":[{"name":"未分类","slug":"未分类","permalink":"https://blog.ryaoknw.site/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"},{"name":"动画","slug":"动画","permalink":"https://blog.ryaoknw.site/categories/%E5%8A%A8%E7%94%BB/"},{"name":"linux","slug":"linux","permalink":"https://blog.ryaoknw.site/categories/linux/"},{"name":"折腾","slug":"折腾","permalink":"https://blog.ryaoknw.site/categories/%E6%8A%98%E8%85%BE/"},{"name":"报错","slug":"报错","permalink":"https://blog.ryaoknw.site/categories/%E6%8A%A5%E9%94%99/"},{"name":"CS","slug":"CS","permalink":"https://blog.ryaoknw.site/categories/CS/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.ryaoknw.site/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.ryaoknw.site/categories/%E7%AC%94%E8%AE%B0/"},{"name":"题解","slug":"题解","permalink":"https://blog.ryaoknw.site/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://blog.ryaoknw.site/tags/%E6%9D%82%E8%B0%88/"},{"name":"private","slug":"private","permalink":"https://blog.ryaoknw.site/tags/private/"},{"name":"动画","slug":"动画","permalink":"https://blog.ryaoknw.site/tags/%E5%8A%A8%E7%94%BB/"},{"name":"评论","slug":"评论","permalink":"https://blog.ryaoknw.site/tags/%E8%AF%84%E8%AE%BA/"},{"name":"敏感词过滤","slug":"敏感词过滤","permalink":"https://blog.ryaoknw.site/tags/%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4/"},{"name":"DFA","slug":"DFA","permalink":"https://blog.ryaoknw.site/tags/DFA/"},{"name":"教程","slug":"教程","permalink":"https://blog.ryaoknw.site/tags/%E6%95%99%E7%A8%8B/"},{"name":"linux","slug":"linux","permalink":"https://blog.ryaoknw.site/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://blog.ryaoknw.site/tags/ubuntu/"},{"name":"wine","slug":"wine","permalink":"https://blog.ryaoknw.site/tags/wine/"},{"name":"jetbrains","slug":"jetbrains","permalink":"https://blog.ryaoknw.site/tags/jetbrains/"},{"name":"go","slug":"go","permalink":"https://blog.ryaoknw.site/tags/go/"},{"name":"qqbot","slug":"qqbot","permalink":"https://blog.ryaoknw.site/tags/qqbot/"},{"name":"线性表","slug":"线性表","permalink":"https://blog.ryaoknw.site/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.ryaoknw.site/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://blog.ryaoknw.site/tags/%E7%AE%97%E6%B3%95/"},{"name":"贪心","slug":"贪心","permalink":"https://blog.ryaoknw.site/tags/%E8%B4%AA%E5%BF%83/"},{"name":"二分查找","slug":"二分查找","permalink":"https://blog.ryaoknw.site/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"排序","slug":"排序","permalink":"https://blog.ryaoknw.site/tags/%E6%8E%92%E5%BA%8F/"},{"name":"hexo","slug":"hexo","permalink":"https://blog.ryaoknw.site/tags/hexo/"},{"name":"http","slug":"http","permalink":"https://blog.ryaoknw.site/tags/http/"},{"name":"nginx","slug":"nginx","permalink":"https://blog.ryaoknw.site/tags/nginx/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://blog.ryaoknw.site/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]}